{"version":3,"file":"index.mjs","sources":["../src/util.js","../src/rect.js","../src/calc.js","../src/index.js"],"sourcesContent":["function cmp(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  return a < b ? -1 : 1;\n}\n\nexport function sorted(iterable, key = null) {\n  let func;\n  if (key === null) {\n    func = x => x;\n  } else if (typeof key === \"function\") {\n    func = key;\n  } else {\n    func = x => x[key];\n  }\n\n  const result = Array.from(iterable);\n  for (let i = 0; i < result.length; i++) {\n    result[i] = { index: i, key: func(result[i]), value: result[i] };\n  }\n  // Ensure that sorting is stable by comparing original indexes if the keys are\n  // equal.\n  result.sort((a, b) => cmp(a.key, b.key) || cmp(a.index, b.index));\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].value;\n  }\n  return result;\n}\n\nexport function permutations(things, cb) {\n  const tmp = Array.from(things);\n  const len = tmp.length;\n\n  function permute(i) {\n    if (i === len) {\n      cb(tmp.slice());\n      return;\n    }\n\n    const orig = tmp[i];\n    for (let j = i; j < len; j += 1) {\n      const pick = tmp[j];\n      tmp[j] = orig;\n      tmp[i] = pick;\n      permute(i + 1);\n      tmp[j] = pick;\n    }\n    tmp[i] = orig;\n  }\n  return permute(0);\n}\n","export class Rect {\n  constructor(left, top, right, bottom) {\n    this._l = left;\n    this._r = right;\n    this._t = top;\n    this._b = bottom;\n  }\n  get left() {\n    return this._l;\n  }\n  get top() {\n    return this._t;\n  }\n  get right() {\n    return this._r;\n  }\n  get bottom() {\n    return this._b;\n  }\n  get x() {\n    return this.left;\n  }\n  get y() {\n    return this.top;\n  }\n  get cx() {\n    return (this.left + this.right) / 2;\n  }\n  get cy() {\n    return (this.top + this.bottom) / 2;\n  }\n  get width() {\n    return this.right - this.left;\n  }\n  get height() {\n    return this.bottom - this.top;\n  }\n  expanded(left, top = left, right = left, bottom = top) {\n    return new Rect(\n      this.left - left,\n      this.top - top,\n      this.right + right,\n      this.bottom + bottom\n    );\n  }\n}\n\nexport function flippedRect({ left, top, right, bottom }) {\n  return new Rect(top, left, bottom, right);\n}\n","import { sorted, permutations } from \"./util\";\n\nfunction calcLevel(node, cache) {\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n  let level = node.hops.reduce((level, hop) => Math.max(level, hop.level), 0);\n  node.prev.forEach(prev => {\n    level = Math.max(calcLevel(prev, cache) + 1, level);\n  });\n  cache.set(node, level);\n  return level;\n}\n\nfunction nodeify(_traces) {\n  // Turn hops into nodes and augment hops with nodes.\n  // Return a new, better trace.\n\n  const nodes = new Map();\n  const traces = _traces.map(trace => {\n    const hops = trace.hops.map(hop => {\n      const nodeId = `${hop.virtual ? \"virtual\" : \"real\"}-${hop.nodeId}`;\n      const node = nodes.get(nodeId) || {\n        id: nodeId,\n        virtual: hop.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      nodes.set(nodeId, node);\n\n      const newHop = {\n        ...hop,\n        nodeId,\n        node\n      };\n      node.hops.push(newHop);\n      node.traceIndexes.add(newHop.traceIndex);\n      return newHop;\n    });\n    return {\n      ...trace,\n      hops\n    };\n  });\n\n  traces.forEach(trace => {\n    const hops = sorted(trace.hops, \"level\");\n    for (let i = 1; i < hops.length; i++) {\n      const left = hops[i - 1];\n      const right = hops[i];\n      if (right.level === left.level + 1) {\n        right.node.prev.add(left.node);\n        left.node.next.add(right.node);\n      }\n    }\n  });\n\n  const cache = new Map();\n  nodes.forEach(node => {\n    node.level = calcLevel(node, cache);\n    node.hops.forEach(hop => (hop.level = node.level));\n  });\n  return traces;\n}\n\nfunction virtualize(traces) {\n  return traces.map(trace => {\n    const newHops = [];\n\n    const hops = sorted(trace.hops, \"level\");\n    hops.forEach((hop, index) => {\n      if (index > 0) {\n        const prev = hops[index - 1];\n        for (let i = prev.level + 1; i < hop.level; i++) {\n          newHops.push({\n            ...prev,\n            level: i,\n            virtual: true,\n            nodeId: `${i}-${prev.nodeId}`\n          });\n        }\n      }\n      newHops.push({\n        ...hop,\n        nodeId: `${hop.level}-${hop.nodeId}`\n      });\n    });\n    return {\n      ...trace,\n      hops: newHops\n    };\n  });\n}\n\nfunction uniques(hops) {\n  // Create multiple hops if one trace contains the same grouping key several times\n\n  const counts = new Map();\n  return sorted(hops, \"level\").map(hop => {\n    const nodeId = hop.nodeId;\n    const count = counts.get(nodeId) || 0;\n    counts.set(nodeId, count + 1);\n    return {\n      ...hop,\n      nodeId: `${count}-${nodeId}`\n    };\n  });\n}\n\nfunction collectLevels(traces) {\n  let maxLevel = 0;\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      maxLevel = Math.max(maxLevel, hop.level);\n    });\n  });\n\n  const levels = new Array(maxLevel + 1);\n  for (let i = 0; i < levels.length; i++) {\n    levels[i] = new Set();\n  }\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      levels[hop.level].add(hop.node);\n    });\n  });\n\n  return levels.map(nodes => {\n    return Array.from(nodes);\n  });\n}\n\nfunction rankedNodes(nodes, traceRanks) {\n  const nodeRanks = new Map();\n  nodes.forEach(node => {\n    let rank = Infinity;\n    node.traceIndexes.forEach(traceIndex => {\n      rank = Math.min(rank, traceRanks[traceIndex]);\n    });\n    nodeRanks.set(node, rank);\n  });\n  return sorted(nodes, node => nodeRanks.get(node));\n}\n\nfunction rankedHops(hops, traceRanks) {\n  return sorted(hops, hop => traceRanks[hop.traceIndex]);\n}\n\nfunction countCrossings(traces, levels, traceRanks) {\n  const hopRanks = new Map();\n  levels.forEach(nodes => {\n    let rank = 0;\n    rankedNodes(nodes, traceRanks).forEach(node => {\n      rankedHops(node.hops, traceRanks).forEach(hop => {\n        hopRanks.set(hop, rank);\n        rank += 1;\n      });\n    });\n  });\n\n  let crossings = 0;\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 0; i < hops.length - 1; i++) {\n      crossings += Math.abs(hopRanks.get(hops[i]) - hopRanks.get(hops[i + 1]));\n    }\n  });\n\n  return crossings;\n}\n\nexport default function(origTraces, options) {\n  const enrichedTraces = origTraces.map((trace, traceIndex) => {\n    const hops = trace.hops.map((hop, hopIndex) => ({\n      traceIndex,\n      hopIndex,\n      nodeId: options.nodeId(hop, hopIndex, trace, traceIndex, origTraces),\n      node: null,\n      defined: options.hopDefined(hop, hopIndex, trace, traceIndex, origTraces),\n      level: options.hopLevel(hop, hopIndex, trace, traceIndex, origTraces),\n      virtual: false,\n      origHop: hop\n    }));\n    return {\n      hops: uniques(hops)\n    };\n  });\n  const traces = nodeify(virtualize(nodeify(enrichedTraces))).map(trace => ({\n    ...trace,\n    hops: sorted(trace.hops, \"level\")\n  }));\n  const levels = collectLevels(traces);\n\n  let bestTraceRanks = [];\n  let minCrossings = Infinity;\n  permutations(traces.map((_, index) => index), traceRanks => {\n    const crossings = countCrossings(traces, levels, traceRanks);\n    if (crossings < minCrossings) {\n      minCrossings = crossings;\n      bestTraceRanks = traceRanks;\n    }\n  });\n\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      node.hops = rankedHops(node.hops, bestTraceRanks);\n    });\n  });\n\n  return {\n    traces,\n    levels: levels.map(nodes => rankedNodes(nodes, bestTraceRanks))\n  };\n}\n","import { sorted } from \"./util\";\nimport { Rect, flippedRect } from \"./rect\";\nimport calc from \"./calc\";\n\nexport function traceCurve() {\n  return function({ points, horizontal, smoothness }) {\n    return points\n      .map(([x1, y1], index) => {\n        if (index === 0) {\n          return `M ${x1} ${y1}`;\n        }\n        const [x0, y0] = points[index - 1];\n        const dx = smoothness * (horizontal ? x1 - x0 : 0);\n        const dy = smoothness * (horizontal ? 0 : y1 - y0);\n        return `C ${x0 + dx} ${y0 + dy},  ${x1 - dx} ${y1 - dy}, ${x1} ${y1}`;\n      })\n      .join(\" \");\n  };\n}\n\nexport function nodeGradient(node) {\n  const { horizontal, traceStops } = node;\n\n  const start = Math.min(...traceStops.map(s => s.start));\n  const end = Math.max(...traceStops.map(s => s.end));\n\n  const stops = [];\n  traceStops.forEach(s => {\n    stops.push(\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.start - start) / (end - start)\n      },\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.end - start) / (end - start)\n      }\n    );\n  });\n\n  return {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: horizontal ? 0 : start,\n    y1: horizontal ? start : 0,\n    x2: horizontal ? 0 : end,\n    y2: horizontal ? end : 0,\n    stops: sorted(stops, \"offset\")\n  };\n}\n\nexport function genUID() {\n  const base = window.location.href.replace(/#.*/, \"\");\n\n  for (;;) {\n    const id = `uid-${Math.random()}`;\n    if (!document.getElementById(id)) {\n      const attr = `url(${base}#${id})`;\n      return {\n        id,\n        toString() {\n          return attr;\n        }\n      };\n    }\n  }\n}\n\nfunction verticalGraph(origTraces, options) {\n  const horizontal = Boolean(options.horizontal());\n  const levelMargin = options.levelMargin();\n  const traceSmoothness = options.traceSmoothness();\n  const traceWidths = origTraces.map((trace, index) => {\n    return options.traceWidth(trace, index, origTraces);\n  });\n\n  const { traces, levels } = calc(origTraces, options);\n\n  const nodeMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        traceWidth: node.hops.reduce(\n          (total, hop) => total + traceWidths[hop.traceIndex],\n          0\n        )\n      };\n      if (!node.virtual) {\n        const [width, height] = options.nodeSize({\n          hops: node.hops.map(hop => hop.origHop),\n          horizontal: Boolean(horizontal)\n        });\n        nm.width = width;\n        nm.height = height;\n      }\n      nm.width = Math.max(nm.width, nm.traceWidth);\n      nodeMetrics.set(node, nm);\n    });\n  });\n\n  let maxNodeWidth = 0;\n  nodeMetrics.forEach(nm => {\n    maxNodeWidth = Math.max(nm.width, maxNodeWidth);\n  });\n  const sortedTraceWidths = sorted(traceWidths);\n  levels.forEach(nodes => {\n    let width = maxNodeWidth;\n    if (nodes.length >= 2) {\n      const leeway = sortedTraceWidths\n        .slice(nodes.length - 1)\n        .reduce((acc, cur) => acc + cur, 0);\n      width = (maxNodeWidth + leeway) / 2;\n    }\n    nodes.forEach((node, index) => {\n      nodeMetrics.get(node).x += (index - (nodes.length - 1) / 2) * width;\n    });\n\n    let overlaps = 0;\n    let maxOverlaps = 0;\n    nodes.forEach(node => {\n      if (node.virtual) {\n        overlaps = 0;\n      } else {\n        overlaps += 1;\n        maxOverlaps = Math.max(overlaps, maxOverlaps);\n      }\n    });\n    nodes.forEach((node, index) => {\n      let y = 0;\n      if (maxOverlaps >= 2 && index % 2 === 0) {\n        const left = index === 0 ? 0 : nodeMetrics.get(nodes[index - 1]).height;\n        const right =\n          index === nodes.length - 1\n            ? 0\n            : nodeMetrics.get(nodes[index + 1]).height;\n        y += Math.max(left, right);\n      }\n      nodeMetrics.get(node).y = y;\n    });\n  });\n\n  const hopMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n\n      let traceOffset = 0;\n      node.hops.forEach(hop => {\n        const traceWidth = traceWidths[hop.traceIndex];\n        hopMetrics.set(hop, {\n          traceWidth,\n          traceOffset,\n          x: nm.x + traceOffset + traceWidth / 2 - nm.traceWidth / 2,\n          top: 0,\n          bottom: 0\n        });\n        traceOffset += traceWidth;\n      });\n    });\n  });\n\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 1; i < hops.length; i++) {\n      const leftHop = hops[i - 1];\n      const left = hopMetrics.get(leftHop);\n      const right = hopMetrics.get(hops[i]);\n      const lnm = nodeMetrics.get(leftHop.node);\n\n      const dy = (3 / 2) * (1 - traceSmoothness) * (2 * levelMargin);\n      const dx = (3 / 2) * (right.x - left.x);\n      const normalLen = Math.sqrt(dx * dx + dy * dy);\n\n      let nudge = 0;\n      if (normalLen > 0) {\n        // Correction\n        const xfix = 1 - dy / normalLen;\n        const slope = dx !== 0 ? dy / dx : 0;\n        const offset = dx / normalLen - slope * xfix;\n\n        if (dx > 0) {\n          nudge =\n            (lnm.traceWidth - left.traceOffset - left.traceWidth) * offset;\n        } else {\n          nudge = -left.traceOffset * offset;\n        }\n      }\n      left.bottom = nudge;\n      right.top = nudge;\n    }\n  });\n\n  const levelMetrics = new Map();\n  let totalHeight = 0;\n  levels.forEach((nodes, level) => {\n    let top = 0;\n    nodes.forEach(node => {\n      node.hops.forEach(hop => {\n        const hm = hopMetrics.get(hop);\n        top = Math.max(hm.top, top);\n      });\n    });\n\n    let height = 0;\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      height = Math.max(height, nm.height + nm.y);\n    });\n\n    levelMetrics.set(level, {\n      top,\n      height,\n      y: totalHeight\n    });\n    totalHeight += height + top + 2 * levelMargin;\n  });\n\n  const result = {\n    nodes: [],\n    traces: [],\n    bounds: null\n  };\n\n  traces.forEach((trace, traceIndex) => {\n    const sections = [];\n\n    const hops = trace.hops;\n    hops.forEach((hop, index) => {\n      if (hop.virtual) {\n        return;\n      }\n\n      let cut = index - 1;\n      while (cut >= 0 && hops[cut].virtual) {\n        cut--;\n      }\n      if (cut >= 0) {\n        sections.push({\n          hops: hops.slice(cut, index + 1),\n          defined: hops[cut].defined && hop.defined\n        });\n      }\n    });\n\n    const joinedSections = sections.splice(0, 1);\n    sections.forEach(section => {\n      const joined = joinedSections[joinedSections.length - 1];\n      if (Boolean(section.defined) === Boolean(joined.defined)) {\n        joined.hops.push(...section.hops.slice(1));\n      } else {\n        joinedSections.push(section);\n      }\n    });\n\n    const pointSections = joinedSections.map(({ hops, defined }) => {\n      const points = [];\n      hops.forEach((right, index) => {\n        const rhm = hopMetrics.get(right);\n        const rnm = nodeMetrics.get(right.node);\n        const rlm = levelMetrics.get(right.level);\n        if (index === 0) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n          return;\n        }\n\n        const lhm = hopMetrics.get(hops[index - 1]);\n        const llm = levelMetrics.get(hops[index - 1].level);\n        const y = llm.y + llm.top + llm.height + lhm.bottom;\n        points.push([lhm.x, y]);\n        points.push([rhm.x, y + 2 * levelMargin]);\n\n        if (index === hops.length - 1) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n        }\n      });\n      return { points, defined };\n    });\n\n    pointSections.forEach(section => {\n      result.traces.push({\n        index: traceIndex,\n        width: traceWidths[traceIndex],\n        hops: trace.hops.map(hop => hop.origHop),\n        defined: section.defined,\n        points: section.points,\n        smoothness: traceSmoothness,\n        horizontal: horizontal\n      });\n    });\n  });\n\n  let left = levels.length === 0 ? 0 : Infinity;\n  let right = levels.length === 0 ? 0 : -Infinity;\n  let top = levels.length === 0 ? 0 : Infinity;\n  let bottom = levels.length === 0 ? 0 : -Infinity;\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      const lm = levelMetrics.get(node.level);\n      const x0 = nm.x - nm.width / 2;\n      const x1 = nm.x + nm.width / 2;\n      const y0 = lm.y + lm.top + nm.y;\n      const y1 = y0 + nm.height;\n\n      left = Math.min(x0, left);\n      right = Math.max(x1, right);\n      top = Math.min(y0, top);\n      bottom = Math.max(y1, bottom);\n      if (node.virtual) {\n        return;\n      }\n\n      let offset = (x0 + x1) / 2 - nm.traceWidth / 2;\n      const traceStops = node.hops.map(hop => {\n        const start = offset;\n        offset += traceWidths[hop.traceIndex];\n        return {\n          start,\n          end: offset,\n          traceIndex: hop.traceIndex\n        };\n      });\n      result.nodes.push({\n        bounds: new Rect(x0, y0, x1, y1),\n        horizontal,\n        hops: node.hops.map(hop => hop.origHop),\n        traceIndexes: node.hops.map(hop => hop.traceIndex),\n        traceStops\n      });\n    });\n  });\n\n  result.bounds = new Rect(left, top, right, bottom);\n  return result;\n}\n\nexport function tracegraph() {\n  const values = {\n    horizontal: false,\n    traceWidth: () => 1,\n    traceSmoothness: 0.5,\n    levelMargin: 10,\n    hopLevel: (hop, index) => index,\n    hopDefined: () => true,\n    nodeSize: () => [10, 10],\n    nodeId: (hop, hopIndex, trace, traceIndex) => `${traceIndex}-${hopIndex}`\n  };\n\n  function graph(traces) {\n    const horizontal = options.horizontal();\n    if (horizontal) {\n      const nodeSize = options.nodeSize;\n      options.nodeSize = (...args) => {\n        const [w, h] = nodeSize(...args);\n        return [h, w];\n      };\n    }\n\n    const result = verticalGraph(traces, options);\n    if (!horizontal) {\n      return result;\n    }\n    return {\n      bounds: flippedRect(result.bounds),\n      traces: result.traces.map(trace => ({\n        ...trace,\n        points: trace.points.map(([x, y]) => [y, x])\n      })),\n      nodes: result.nodes.map(node => ({\n        ...node,\n        bounds: flippedRect(node.bounds)\n      }))\n    };\n  }\n\n  const options = {};\n  Object.keys(values).forEach(key => {\n    graph[key] = function(value) {\n      if (arguments.length === 0) {\n        return values[key];\n      }\n      values[key] = value;\n      options[key] = typeof value === \"function\" ? value : () => value;\n      return graph;\n    };\n    graph[key](values[key]);\n  });\n  return graph;\n}\n"],"names":["cmp","a","b","sorted","iterable","key","func","x","result","Array","from","i","length","index","value","sort","let","Rect","constructor","left","top","right","bottom","_l","_r","_t","_b","flippedRect","ref","nodeify","_traces","nodes","Map","traces","map","trace","hops","hop","nodeId","virtual","node","get","id","level","prev","Set","next","traceIndexes","set","newHop","Object","push","add","traceIndex","forEach","cache","calcLevel","has","reduce","Math","max","uniques","counts","count","rankedNodes","traceRanks","nodeRanks","rank","Infinity","min","rankedHops","origTraces","options","things","cb","tmp","len","newHops","virtualize","hopIndex","defined","hopDefined","hopLevel","origHop","levels","maxLevel","collectLevels","bestTraceRanks","minCrossings","_","crossings","hopRanks","abs","countCrossings","permute","orig","j","pick","slice","traceCurve","points","x1","y1","dx","smoothness","horizontal","x0","dy","y0","join","nodeGradient","start","traceStops","s","end","stops","offset","gradientUnits","x2","y2","genUID","base","window","location","href","replace","random","document","getElementById","attr","toString","tracegraph","values","traceWidth","traceSmoothness","levelMargin","nodeSize","graph","args","Boolean","traceWidths","calc","nodeMetrics","nm","y","width","height","total","maxNodeWidth","sortedTraceWidths","leeway","acc","cur","overlaps","maxOverlaps","hopMetrics","traceOffset","leftHop","lnm","normalLen","sqrt","nudge","levelMetrics","totalHeight","hm","bounds","sections","cut","joinedSections","splice","section","joined","rhm","rnm","rlm","lhm","llm","lm","verticalGraph","keys","arguments","prototypeAccessors","this","cx","cy","expanded"],"mappings":"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"}