{"version":3,"file":"index.umd.js","sources":["../src/util.js","../src/rect.js","../src/calc.js","../src/index.js"],"sourcesContent":["function cmp(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  return a < b ? -1 : 1;\n}\n\nexport function sorted(iterable, key = null) {\n  let func;\n  if (key === null) {\n    func = x => x;\n  } else if (typeof key === \"function\") {\n    func = key;\n  } else {\n    func = x => x[key];\n  }\n\n  const result = Array.from(iterable);\n  for (let i = 0; i < result.length; i++) {\n    result[i] = { index: i, key: func(result[i]), value: result[i] };\n  }\n  // Ensure that sorting is stable by comparing original indexes if the keys are\n  // equal.\n  result.sort((a, b) => cmp(a.key, b.key) || cmp(a.index, b.index));\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].value;\n  }\n  return result;\n}\n\nexport function permutations(things, cb) {\n  const tmp = Array.from(things);\n  const len = tmp.length;\n\n  function permute(i) {\n    if (i === len) {\n      cb(tmp.slice());\n      return;\n    }\n\n    const orig = tmp[i];\n    for (let j = i; j < len; j += 1) {\n      const pick = tmp[j];\n      tmp[j] = orig;\n      tmp[i] = pick;\n      permute(i + 1);\n      tmp[j] = pick;\n    }\n    tmp[i] = orig;\n  }\n  return permute(0);\n}\n","export class Rect {\n  constructor(left, top, right, bottom) {\n    this._l = left;\n    this._r = right;\n    this._t = top;\n    this._b = bottom;\n  }\n  get left() {\n    return this._l;\n  }\n  get top() {\n    return this._t;\n  }\n  get right() {\n    return this._r;\n  }\n  get bottom() {\n    return this._b;\n  }\n  get x() {\n    return this.left;\n  }\n  get y() {\n    return this.top;\n  }\n  get cx() {\n    return (this.left + this.right) / 2;\n  }\n  get cy() {\n    return (this.top + this.bottom) / 2;\n  }\n  get width() {\n    return this.right - this.left;\n  }\n  get height() {\n    return this.bottom - this.top;\n  }\n  expanded(left, top = left, right = left, bottom = top) {\n    return new Rect(\n      this.left - left,\n      this.top - top,\n      this.right + right,\n      this.bottom + bottom\n    );\n  }\n}\n\nexport function flippedRect({ left, top, right, bottom }) {\n  return new Rect(top, left, bottom, right);\n}\n","import { sorted, permutations } from \"./util\";\n\nfunction calcLevel(node, cache) {\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n  let level = node.hops.reduce((level, hop) => Math.max(level, hop.level), 0);\n  node.prev.forEach(prev => {\n    level = Math.max(calcLevel(prev, cache) + 1, level);\n  });\n  cache.set(node, level);\n  return level;\n}\n\nfunction nodeify(_traces) {\n  // Turn hops into nodes and augment hops with nodes.\n  // Return a new, better trace.\n\n  const nodes = new Map();\n  const traces = _traces.map(trace => {\n    const hops = trace.hops.map(hop => {\n      const nodeId = `${hop.virtual ? \"virtual\" : \"real\"}-${hop.nodeId}`;\n      const node = nodes.get(nodeId) || {\n        id: nodeId,\n        virtual: hop.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      nodes.set(nodeId, node);\n\n      const newHop = {\n        ...hop,\n        nodeId,\n        node\n      };\n      node.hops.push(newHop);\n      node.traceIndexes.add(newHop.traceIndex);\n      return newHop;\n    });\n    return {\n      ...trace,\n      hops\n    };\n  });\n\n  traces.forEach(trace => {\n    const hops = sorted(trace.hops, \"level\");\n    for (let i = 1; i < hops.length; i++) {\n      const left = hops[i - 1];\n      const right = hops[i];\n      if (right.level === left.level + 1) {\n        right.node.prev.add(left.node);\n        left.node.next.add(right.node);\n      }\n    }\n  });\n\n  const cache = new Map();\n  nodes.forEach(node => {\n    node.level = calcLevel(node, cache);\n    node.hops.forEach(hop => (hop.level = node.level));\n  });\n  return traces;\n}\n\nfunction virtualize(traces) {\n  return traces.map(trace => {\n    const newHops = [];\n\n    const hops = sorted(trace.hops, \"level\");\n    hops.forEach((hop, index) => {\n      if (index > 0) {\n        const prev = hops[index - 1];\n        for (let i = prev.level + 1; i < hop.level; i++) {\n          newHops.push({\n            ...prev,\n            level: i,\n            virtual: true,\n            nodeId: `${i}-${prev.nodeId}`\n          });\n        }\n      }\n      newHops.push({\n        ...hop,\n        nodeId: `${hop.level}-${hop.nodeId}`\n      });\n    });\n    return {\n      ...trace,\n      hops: newHops\n    };\n  });\n}\n\nfunction uniques(hops) {\n  // Create multiple hops if one trace contains the same grouping key several times\n\n  const counts = new Map();\n  return sorted(hops, \"level\").map(hop => {\n    const nodeId = hop.nodeId;\n    const count = counts.get(nodeId) || 0;\n    counts.set(nodeId, count + 1);\n    return {\n      ...hop,\n      nodeId: `${count}-${nodeId}`\n    };\n  });\n}\n\nfunction collectLevels(traces) {\n  let maxLevel = 0;\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      maxLevel = Math.max(maxLevel, hop.level);\n    });\n  });\n\n  const levels = new Array(maxLevel + 1);\n  for (let i = 0; i < levels.length; i++) {\n    levels[i] = new Set();\n  }\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      levels[hop.level].add(hop.node);\n    });\n  });\n\n  return levels.map(nodes => {\n    return Array.from(nodes);\n  });\n}\n\nfunction rankedNodes(nodes, traceRanks) {\n  const nodeRanks = new Map();\n  nodes.forEach(node => {\n    let rank = Infinity;\n    node.traceIndexes.forEach(traceIndex => {\n      rank = Math.min(rank, traceRanks[traceIndex]);\n    });\n    nodeRanks.set(node, rank);\n  });\n  return sorted(nodes, node => nodeRanks.get(node));\n}\n\nfunction rankedHops(hops, traceRanks) {\n  return sorted(hops, hop => traceRanks[hop.traceIndex]);\n}\n\nfunction countCrossings(traces, levels, traceRanks) {\n  const hopRanks = new Map();\n  levels.forEach(nodes => {\n    let rank = 0;\n    rankedNodes(nodes, traceRanks).forEach(node => {\n      rankedHops(node.hops, traceRanks).forEach(hop => {\n        hopRanks.set(hop, rank);\n        rank += 1;\n      });\n    });\n  });\n\n  let crossings = 0;\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 0; i < hops.length - 1; i++) {\n      crossings += Math.abs(hopRanks.get(hops[i]) - hopRanks.get(hops[i + 1]));\n    }\n  });\n\n  return crossings;\n}\n\nexport default function(origTraces, options) {\n  const enrichedTraces = origTraces.map((trace, traceIndex) => {\n    const hops = trace.hops.map((hop, hopIndex) => ({\n      traceIndex,\n      hopIndex,\n      nodeId: options.nodeId(hop, hopIndex, trace, traceIndex, origTraces),\n      node: null,\n      defined: options.hopDefined(hop, hopIndex, trace, traceIndex, origTraces),\n      level: options.hopLevel(hop, hopIndex, trace, traceIndex, origTraces),\n      virtual: false,\n      origHop: hop\n    }));\n    return {\n      hops: uniques(hops)\n    };\n  });\n  const traces = nodeify(virtualize(nodeify(enrichedTraces))).map(trace => ({\n    ...trace,\n    hops: sorted(trace.hops, \"level\")\n  }));\n  const levels = collectLevels(traces);\n\n  let bestTraceRanks = [];\n  let minCrossings = Infinity;\n  permutations(traces.map((_, index) => index), traceRanks => {\n    const crossings = countCrossings(traces, levels, traceRanks);\n    if (crossings < minCrossings) {\n      minCrossings = crossings;\n      bestTraceRanks = traceRanks;\n    }\n  });\n\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      node.hops = rankedHops(node.hops, bestTraceRanks);\n    });\n  });\n\n  return {\n    traces,\n    levels: levels.map(nodes => rankedNodes(nodes, bestTraceRanks))\n  };\n}\n","import { sorted } from \"./util\";\nimport { Rect, flippedRect } from \"./rect\";\nimport calc from \"./calc\";\n\nexport function traceCurve() {\n  return function({ points, horizontal, smoothness }) {\n    return points\n      .map(([x1, y1], index) => {\n        if (index === 0) {\n          return `M ${x1} ${y1}`;\n        }\n        const [x0, y0] = points[index - 1];\n        const dx = smoothness * (horizontal ? x1 - x0 : 0);\n        const dy = smoothness * (horizontal ? 0 : y1 - y0);\n        return `C ${x0 + dx} ${y0 + dy},  ${x1 - dx} ${y1 - dy}, ${x1} ${y1}`;\n      })\n      .join(\" \");\n  };\n}\n\nexport function nodeGradient(node) {\n  const { horizontal, traceStops } = node;\n\n  const start = Math.min(...traceStops.map(s => s.start));\n  const end = Math.max(...traceStops.map(s => s.end));\n\n  const stops = [];\n  traceStops.forEach(s => {\n    stops.push(\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.start - start) / (end - start)\n      },\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.end - start) / (end - start)\n      }\n    );\n  });\n\n  return {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: horizontal ? 0 : start,\n    y1: horizontal ? start : 0,\n    x2: horizontal ? 0 : end,\n    y2: horizontal ? end : 0,\n    stops: sorted(stops, \"offset\")\n  };\n}\n\nexport function genUID() {\n  const base = window.location.href.replace(/#.*/, \"\");\n\n  for (;;) {\n    const id = `uid-${Math.random()}`;\n    if (!document.getElementById(id)) {\n      const attr = `url(${base}#${id})`;\n      return {\n        id,\n        toString() {\n          return attr;\n        }\n      };\n    }\n  }\n}\n\nfunction verticalGraph(origTraces, options) {\n  const horizontal = Boolean(options.horizontal());\n  const levelMargin = options.levelMargin();\n  const traceSmoothness = options.traceSmoothness();\n  const traceWidths = origTraces.map((trace, index) => {\n    return options.traceWidth(trace, index, origTraces);\n  });\n\n  const { traces, levels } = calc(origTraces, options);\n\n  const nodeMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        traceWidth: node.hops.reduce(\n          (total, hop) => total + traceWidths[hop.traceIndex],\n          0\n        )\n      };\n      if (!node.virtual) {\n        const [width, height] = options.nodeSize({\n          hops: node.hops.map(hop => hop.origHop),\n          horizontal: Boolean(horizontal)\n        });\n        nm.width = width;\n        nm.height = height;\n      }\n      nm.width = Math.max(nm.width, nm.traceWidth);\n      nodeMetrics.set(node, nm);\n    });\n  });\n\n  let maxNodeWidth = 0;\n  nodeMetrics.forEach(nm => {\n    maxNodeWidth = Math.max(nm.width, maxNodeWidth);\n  });\n  const sortedTraceWidths = sorted(traceWidths);\n  levels.forEach(nodes => {\n    let width = maxNodeWidth;\n    if (nodes.length >= 2) {\n      const leeway = sortedTraceWidths\n        .slice(nodes.length - 1)\n        .reduce((acc, cur) => acc + cur, 0);\n      width = (maxNodeWidth + leeway) / 2;\n    }\n    nodes.forEach((node, index) => {\n      nodeMetrics.get(node).x += (index - (nodes.length - 1) / 2) * width;\n    });\n\n    let overlaps = 0;\n    let maxOverlaps = 0;\n    nodes.forEach(node => {\n      if (node.virtual) {\n        overlaps = 0;\n      } else {\n        overlaps += 1;\n        maxOverlaps = Math.max(overlaps, maxOverlaps);\n      }\n    });\n    nodes.forEach((node, index) => {\n      let y = 0;\n      if (maxOverlaps >= 2 && index % 2 === 0) {\n        const left = index === 0 ? 0 : nodeMetrics.get(nodes[index - 1]).height;\n        const right =\n          index === nodes.length - 1\n            ? 0\n            : nodeMetrics.get(nodes[index + 1]).height;\n        y += Math.max(left, right);\n      }\n      nodeMetrics.get(node).y = y;\n    });\n  });\n\n  const hopMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n\n      let traceOffset = 0;\n      node.hops.forEach(hop => {\n        const traceWidth = traceWidths[hop.traceIndex];\n        hopMetrics.set(hop, {\n          traceWidth,\n          traceOffset,\n          x: nm.x + traceOffset + traceWidth / 2 - nm.traceWidth / 2,\n          top: 0,\n          bottom: 0\n        });\n        traceOffset += traceWidth;\n      });\n    });\n  });\n\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 1; i < hops.length; i++) {\n      const leftHop = hops[i - 1];\n      const left = hopMetrics.get(leftHop);\n      const right = hopMetrics.get(hops[i]);\n      const lnm = nodeMetrics.get(leftHop.node);\n\n      const dy = (3 / 2) * (1 - traceSmoothness) * (2 * levelMargin);\n      const dx = (3 / 2) * (right.x - left.x);\n      const normalLen = Math.sqrt(dx * dx + dy * dy);\n\n      let nudge = 0;\n      if (normalLen > 0) {\n        // Correction\n        const xfix = 1 - dy / normalLen;\n        const slope = dx !== 0 ? dy / dx : 0;\n        const offset = dx / normalLen - slope * xfix;\n\n        if (dx > 0) {\n          nudge =\n            (lnm.traceWidth - left.traceOffset - left.traceWidth) * offset;\n        } else {\n          nudge = -left.traceOffset * offset;\n        }\n      }\n      left.bottom = nudge;\n      right.top = nudge;\n    }\n  });\n\n  const levelMetrics = new Map();\n  let totalHeight = 0;\n  levels.forEach((nodes, level) => {\n    let top = 0;\n    nodes.forEach(node => {\n      node.hops.forEach(hop => {\n        const hm = hopMetrics.get(hop);\n        top = Math.max(hm.top, top);\n      });\n    });\n\n    let height = 0;\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      height = Math.max(height, nm.height + nm.y);\n    });\n\n    levelMetrics.set(level, {\n      top,\n      height,\n      y: totalHeight\n    });\n    totalHeight += height + top + 2 * levelMargin;\n  });\n\n  const result = {\n    nodes: [],\n    traces: [],\n    bounds: null\n  };\n\n  traces.forEach((trace, traceIndex) => {\n    const sections = [];\n\n    const hops = trace.hops;\n    hops.forEach((hop, index) => {\n      if (hop.virtual) {\n        return;\n      }\n\n      let cut = index - 1;\n      while (cut >= 0 && hops[cut].virtual) {\n        cut--;\n      }\n      if (cut >= 0) {\n        sections.push({\n          hops: hops.slice(cut, index + 1),\n          defined: hops[cut].defined && hop.defined\n        });\n      }\n    });\n\n    const joinedSections = sections.splice(0, 1);\n    sections.forEach(section => {\n      const joined = joinedSections[joinedSections.length - 1];\n      if (Boolean(section.defined) === Boolean(joined.defined)) {\n        joined.hops.push(...section.hops.slice(1));\n      } else {\n        joinedSections.push(section);\n      }\n    });\n\n    const pointSections = joinedSections.map(({ hops, defined }) => {\n      const points = [];\n      hops.forEach((right, index) => {\n        const rhm = hopMetrics.get(right);\n        const rnm = nodeMetrics.get(right.node);\n        const rlm = levelMetrics.get(right.level);\n        if (index === 0) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n          return;\n        }\n\n        const lhm = hopMetrics.get(hops[index - 1]);\n        const llm = levelMetrics.get(hops[index - 1].level);\n        const y = llm.y + llm.top + llm.height + lhm.bottom;\n        points.push([lhm.x, y]);\n        points.push([rhm.x, y + 2 * levelMargin]);\n\n        if (index === hops.length - 1) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n        }\n      });\n      return { points, defined };\n    });\n\n    pointSections.forEach(section => {\n      result.traces.push({\n        index: traceIndex,\n        width: traceWidths[traceIndex],\n        hops: trace.hops.map(hop => hop.origHop),\n        defined: section.defined,\n        points: section.points,\n        smoothness: traceSmoothness,\n        horizontal: horizontal\n      });\n    });\n  });\n\n  let left = levels.length === 0 ? 0 : Infinity;\n  let right = levels.length === 0 ? 0 : -Infinity;\n  let top = levels.length === 0 ? 0 : Infinity;\n  let bottom = levels.length === 0 ? 0 : -Infinity;\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      const lm = levelMetrics.get(node.level);\n      const x0 = nm.x - nm.width / 2;\n      const x1 = nm.x + nm.width / 2;\n      const y0 = lm.y + lm.top + nm.y;\n      const y1 = y0 + nm.height;\n\n      left = Math.min(x0, left);\n      right = Math.max(x1, right);\n      top = Math.min(y0, top);\n      bottom = Math.max(y1, bottom);\n      if (node.virtual) {\n        return;\n      }\n\n      let offset = (x0 + x1) / 2 - nm.traceWidth / 2;\n      const traceStops = node.hops.map(hop => {\n        const start = offset;\n        offset += traceWidths[hop.traceIndex];\n        return {\n          start,\n          end: offset,\n          traceIndex: hop.traceIndex\n        };\n      });\n      result.nodes.push({\n        bounds: new Rect(x0, y0, x1, y1),\n        horizontal,\n        hops: node.hops.map(hop => hop.origHop),\n        traceIndexes: node.hops.map(hop => hop.traceIndex),\n        traceStops\n      });\n    });\n  });\n\n  result.bounds = new Rect(left, top, right, bottom);\n  return result;\n}\n\nexport function tracegraph() {\n  const values = {\n    horizontal: false,\n    traceWidth: () => 1,\n    traceSmoothness: 0.5,\n    levelMargin: 10,\n    hopLevel: (hop, index) => index,\n    hopDefined: () => true,\n    nodeSize: () => [10, 10],\n    nodeId: (hop, hopIndex, trace, traceIndex) => `${traceIndex}-${hopIndex}`\n  };\n\n  function graph(traces) {\n    const horizontal = options.horizontal();\n    if (horizontal) {\n      const nodeSize = options.nodeSize;\n      options.nodeSize = (...args) => {\n        const [w, h] = nodeSize(...args);\n        return [h, w];\n      };\n    }\n\n    const result = verticalGraph(traces, options);\n    if (!horizontal) {\n      return result;\n    }\n    return {\n      bounds: flippedRect(result.bounds),\n      traces: result.traces.map(trace => ({\n        ...trace,\n        points: trace.points.map(([x, y]) => [y, x])\n      })),\n      nodes: result.nodes.map(node => ({\n        ...node,\n        bounds: flippedRect(node.bounds)\n      }))\n    };\n  }\n\n  const options = {};\n  Object.keys(values).forEach(key => {\n    graph[key] = function(value) {\n      if (arguments.length === 0) {\n        return values[key];\n      }\n      values[key] = value;\n      options[key] = typeof value === \"function\" ? value : () => value;\n      return graph;\n    };\n    graph[key](values[key]);\n  });\n  return graph;\n}\n"],"names":["cmp","a","b","sorted","iterable","key","func","x","result","Array","from","i","length","index","value","sort","let","Rect","constructor","left","top","right","bottom","_l","_r","_t","_b","flippedRect","ref","nodeify","_traces","nodes","Map","traces","map","trace","hops","hop","nodeId","virtual","node","get","id","level","prev","Set","next","traceIndexes","set","newHop","Object","push","add","traceIndex","forEach","cache","calcLevel","has","reduce","Math","max","uniques","counts","count","rankedNodes","traceRanks","nodeRanks","rank","Infinity","min","rankedHops","origTraces","options","things","cb","tmp","len","newHops","virtualize","hopIndex","defined","hopDefined","hopLevel","origHop","levels","maxLevel","collectLevels","bestTraceRanks","minCrossings","_","crossings","hopRanks","abs","countCrossings","permute","orig","j","pick","slice","prototypeAccessors","this","y","cx","cy","width","height","expanded","points","x1","y1","dx","smoothness","horizontal","x0","dy","y0","join","start","traceStops","s","end","stops","offset","gradientUnits","x2","y2","base","window","location","href","replace","random","document","getElementById","attr","toString","values","traceWidth","traceSmoothness","levelMargin","nodeSize","graph","args","Boolean","traceWidths","calc","nodeMetrics","nm","total","maxNodeWidth","sortedTraceWidths","leeway","acc","cur","overlaps","maxOverlaps","hopMetrics","traceOffset","leftHop","lnm","normalLen","sqrt","nudge","levelMetrics","totalHeight","hm","bounds","sections","cut","joinedSections","splice","section","joined","rhm","rnm","rlm","lhm","llm","lm","verticalGraph","keys","arguments"],"mappings":"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"}