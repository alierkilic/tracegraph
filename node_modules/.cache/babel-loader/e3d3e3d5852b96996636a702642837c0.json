{"ast":null,"code":"import { sorted, permutations } from \"./util\";\n\nfunction calcLevel(node, cache) {\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n\n  let level = node.hops.reduce((level, hop) => Math.max(level, hop.level), 0);\n  node.prev.forEach(prev => {\n    level = Math.max(calcLevel(prev, cache) + 1, level);\n  });\n  cache.set(node, level);\n  return level;\n}\n\nfunction nodeify(_traces) {\n  // Turn hops into nodes and augment hops with nodes.\n  // Return a new, better trace.\n  const nodes = new Map();\n\n  const traces = _traces.map(trace => {\n    const hops = trace.hops.map(hop => {\n      const nodeId = `${hop.virtual ? \"virtual\" : \"real\"}-${hop.nodeId}`;\n      const node = nodes.get(nodeId) || {\n        id: nodeId,\n        virtual: hop.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      nodes.set(nodeId, node);\n      const newHop = { ...hop,\n        nodeId,\n        node\n      };\n      node.hops.push(newHop);\n      node.traceIndexes.add(newHop.traceIndex);\n      return newHop;\n    });\n    return { ...trace,\n      hops\n    };\n  });\n\n  traces.forEach(trace => {\n    const hops = sorted(trace.hops, \"level\");\n\n    for (let i = 1; i < hops.length; i++) {\n      const left = hops[i - 1];\n      const right = hops[i];\n\n      if (right.level === left.level + 1) {\n        right.node.prev.add(left.node);\n        left.node.next.add(right.node);\n      }\n    }\n  });\n  const cache = new Map();\n  nodes.forEach(node => {\n    node.level = calcLevel(node, cache);\n    node.hops.forEach(hop => hop.level = node.level);\n  });\n  return traces;\n}\n\nfunction virtualize(traces) {\n  return traces.map(trace => {\n    const newHops = [];\n    const hops = sorted(trace.hops, \"level\");\n    hops.forEach((hop, index) => {\n      if (index > 0) {\n        const prev = hops[index - 1];\n\n        for (let i = prev.level + 1; i < hop.level; i++) {\n          newHops.push({ ...prev,\n            level: i,\n            virtual: true,\n            nodeId: `${i}-${prev.nodeId}`\n          });\n        }\n      }\n\n      newHops.push({ ...hop,\n        nodeId: `${hop.level}-${hop.nodeId}`\n      });\n    });\n    return { ...trace,\n      hops: newHops\n    };\n  });\n}\n\nfunction uniques(hops) {\n  // Create multiple hops if one trace contains the same grouping key several times\n  const counts = new Map();\n  return sorted(hops, \"level\").map(hop => {\n    const nodeId = hop.nodeId;\n    const count = counts.get(nodeId) || 0;\n    counts.set(nodeId, count + 1);\n    return { ...hop,\n      nodeId: `${count}-${nodeId}`\n    };\n  });\n}\n\nfunction collectLevels(traces) {\n  let maxLevel = 0;\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      maxLevel = Math.max(maxLevel, hop.level);\n    });\n  });\n  const levels = new Array(maxLevel + 1);\n\n  for (let i = 0; i < levels.length; i++) {\n    levels[i] = new Set();\n  }\n\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      levels[hop.level].add(hop.node);\n    });\n  });\n  return levels.map(nodes => {\n    return Array.from(nodes);\n  });\n}\n\nfunction rankedNodes(nodes, traceRanks) {\n  const nodeRanks = new Map();\n  nodes.forEach(node => {\n    let rank = Infinity;\n    node.traceIndexes.forEach(traceIndex => {\n      rank = Math.min(rank, traceRanks[traceIndex]);\n    });\n    nodeRanks.set(node, rank);\n  });\n  return sorted(nodes, node => nodeRanks.get(node));\n}\n\nfunction rankedHops(hops, traceRanks) {\n  return sorted(hops, hop => traceRanks[hop.traceIndex]);\n}\n\nfunction countCrossings(traces, levels, traceRanks) {\n  const hopRanks = new Map();\n  levels.forEach(nodes => {\n    let rank = 0;\n    rankedNodes(nodes, traceRanks).forEach(node => {\n      rankedHops(node.hops, traceRanks).forEach(hop => {\n        hopRanks.set(hop, rank);\n        rank += 1;\n      });\n    });\n  });\n  let crossings = 0;\n  traces.forEach(trace => {\n    const hops = trace.hops;\n\n    for (let i = 0; i < hops.length - 1; i++) {\n      crossings += Math.abs(hopRanks.get(hops[i]) - hopRanks.get(hops[i + 1]));\n    }\n  });\n  return crossings;\n}\n\nexport default function (origTraces, options) {\n  const enrichedTraces = origTraces.map((trace, traceIndex) => {\n    const hops = trace.hops.map((hop, hopIndex) => ({\n      traceIndex,\n      hopIndex,\n      nodeId: options.nodeId(hop, hopIndex, trace, traceIndex, origTraces),\n      node: null,\n      defined: options.hopDefined(hop, hopIndex, trace, traceIndex, origTraces),\n      level: options.hopLevel(hop, hopIndex, trace, traceIndex, origTraces),\n      virtual: false,\n      origHop: hop\n    }));\n    return {\n      hops: uniques(hops)\n    };\n  });\n  const traces = nodeify(virtualize(nodeify(enrichedTraces))).map(trace => ({ ...trace,\n    hops: sorted(trace.hops, \"level\")\n  }));\n  const levels = collectLevels(traces);\n  let bestTraceRanks = [];\n  let minCrossings = Infinity;\n  permutations(traces.map((_, index) => index), traceRanks => {\n    const crossings = countCrossings(traces, levels, traceRanks);\n\n    if (crossings < minCrossings) {\n      minCrossings = crossings;\n      bestTraceRanks = traceRanks;\n    }\n  });\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      node.hops = rankedHops(node.hops, bestTraceRanks);\n    });\n  });\n  return {\n    traces,\n    levels: levels.map(nodes => rankedNodes(nodes, bestTraceRanks))\n  };\n}","map":{"version":3,"sources":["/Users/alican/Desktop/trace/src/calc.js"],"names":["sorted","permutations","calcLevel","node","cache","has","get","level","hops","reduce","hop","Math","max","prev","forEach","set","nodeify","_traces","nodes","Map","traces","map","trace","nodeId","virtual","id","Set","next","traceIndexes","newHop","push","add","traceIndex","i","length","left","right","virtualize","newHops","index","uniques","counts","count","collectLevels","maxLevel","levels","Array","from","rankedNodes","traceRanks","nodeRanks","rank","Infinity","min","rankedHops","countCrossings","hopRanks","crossings","abs","origTraces","options","enrichedTraces","hopIndex","defined","hopDefined","hopLevel","origHop","bestTraceRanks","minCrossings","_"],"mappings":"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","sourcesContent":["import { sorted, permutations } from \"./util\";\n\nfunction calcLevel(node, cache) {\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n  let level = node.hops.reduce((level, hop) => Math.max(level, hop.level), 0);\n  node.prev.forEach(prev => {\n    level = Math.max(calcLevel(prev, cache) + 1, level);\n  });\n  cache.set(node, level);\n  return level;\n}\n\nfunction nodeify(_traces) {\n  // Turn hops into nodes and augment hops with nodes.\n  // Return a new, better trace.\n\n  const nodes = new Map();\n  const traces = _traces.map(trace => {\n    const hops = trace.hops.map(hop => {\n      const nodeId = `${hop.virtual ? \"virtual\" : \"real\"}-${hop.nodeId}`;\n      const node = nodes.get(nodeId) || {\n        id: nodeId,\n        virtual: hop.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      nodes.set(nodeId, node);\n\n      const newHop = {\n        ...hop,\n        nodeId,\n        node\n      };\n      node.hops.push(newHop);\n      node.traceIndexes.add(newHop.traceIndex);\n      return newHop;\n    });\n    return {\n      ...trace,\n      hops\n    };\n  });\n\n  traces.forEach(trace => {\n    const hops = sorted(trace.hops, \"level\");\n    for (let i = 1; i < hops.length; i++) {\n      const left = hops[i - 1];\n      const right = hops[i];\n      if (right.level === left.level + 1) {\n        right.node.prev.add(left.node);\n        left.node.next.add(right.node);\n      }\n    }\n  });\n\n  const cache = new Map();\n  nodes.forEach(node => {\n    node.level = calcLevel(node, cache);\n    node.hops.forEach(hop => (hop.level = node.level));\n  });\n  return traces;\n}\n\nfunction virtualize(traces) {\n  return traces.map(trace => {\n    const newHops = [];\n\n    const hops = sorted(trace.hops, \"level\");\n    hops.forEach((hop, index) => {\n      if (index > 0) {\n        const prev = hops[index - 1];\n        for (let i = prev.level + 1; i < hop.level; i++) {\n          newHops.push({\n            ...prev,\n            level: i,\n            virtual: true,\n            nodeId: `${i}-${prev.nodeId}`\n          });\n        }\n      }\n      newHops.push({\n        ...hop,\n        nodeId: `${hop.level}-${hop.nodeId}`\n      });\n    });\n    return {\n      ...trace,\n      hops: newHops\n    };\n  });\n}\n\nfunction uniques(hops) {\n  // Create multiple hops if one trace contains the same grouping key several times\n\n  const counts = new Map();\n  return sorted(hops, \"level\").map(hop => {\n    const nodeId = hop.nodeId;\n    const count = counts.get(nodeId) || 0;\n    counts.set(nodeId, count + 1);\n    return {\n      ...hop,\n      nodeId: `${count}-${nodeId}`\n    };\n  });\n}\n\nfunction collectLevels(traces) {\n  let maxLevel = 0;\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      maxLevel = Math.max(maxLevel, hop.level);\n    });\n  });\n\n  const levels = new Array(maxLevel + 1);\n  for (let i = 0; i < levels.length; i++) {\n    levels[i] = new Set();\n  }\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      levels[hop.level].add(hop.node);\n    });\n  });\n\n  return levels.map(nodes => {\n    return Array.from(nodes);\n  });\n}\n\nfunction rankedNodes(nodes, traceRanks) {\n  const nodeRanks = new Map();\n  nodes.forEach(node => {\n    let rank = Infinity;\n    node.traceIndexes.forEach(traceIndex => {\n      rank = Math.min(rank, traceRanks[traceIndex]);\n    });\n    nodeRanks.set(node, rank);\n  });\n  return sorted(nodes, node => nodeRanks.get(node));\n}\n\nfunction rankedHops(hops, traceRanks) {\n  return sorted(hops, hop => traceRanks[hop.traceIndex]);\n}\n\nfunction countCrossings(traces, levels, traceRanks) {\n  const hopRanks = new Map();\n  levels.forEach(nodes => {\n    let rank = 0;\n    rankedNodes(nodes, traceRanks).forEach(node => {\n      rankedHops(node.hops, traceRanks).forEach(hop => {\n        hopRanks.set(hop, rank);\n        rank += 1;\n      });\n    });\n  });\n\n  let crossings = 0;\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 0; i < hops.length - 1; i++) {\n      crossings += Math.abs(hopRanks.get(hops[i]) - hopRanks.get(hops[i + 1]));\n    }\n  });\n\n  return crossings;\n}\n\nexport default function(origTraces, options) {\n  const enrichedTraces = origTraces.map((trace, traceIndex) => {\n    const hops = trace.hops.map((hop, hopIndex) => ({\n      traceIndex,\n      hopIndex,\n      nodeId: options.nodeId(hop, hopIndex, trace, traceIndex, origTraces),\n      node: null,\n      defined: options.hopDefined(hop, hopIndex, trace, traceIndex, origTraces),\n      level: options.hopLevel(hop, hopIndex, trace, traceIndex, origTraces),\n      virtual: false,\n      origHop: hop\n    }));\n    return {\n      hops: uniques(hops)\n    };\n  });\n  const traces = nodeify(virtualize(nodeify(enrichedTraces))).map(trace => ({\n    ...trace,\n    hops: sorted(trace.hops, \"level\")\n  }));\n  const levels = collectLevels(traces);\n\n  let bestTraceRanks = [];\n  let minCrossings = Infinity;\n  permutations(traces.map((_, index) => index), traceRanks => {\n    const crossings = countCrossings(traces, levels, traceRanks);\n    if (crossings < minCrossings) {\n      minCrossings = crossings;\n      bestTraceRanks = traceRanks;\n    }\n  });\n\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      node.hops = rankedHops(node.hops, bestTraceRanks);\n    });\n  });\n\n  return {\n    traces,\n    levels: levels.map(nodes => rankedNodes(nodes, bestTraceRanks))\n  };\n}"]},"metadata":{},"sourceType":"module"}