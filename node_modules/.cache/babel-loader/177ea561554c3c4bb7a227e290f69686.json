{"ast":null,"code":"function cmp(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  return a < b ? -1 : 1;\n}\n\nexport function sorted(iterable, key = null) {\n  let func;\n\n  if (key === null) {\n    func = x => x;\n  } else if (typeof key === \"function\") {\n    func = key;\n  } else {\n    func = x => x[key];\n  }\n\n  const result = Array.from(iterable);\n\n  for (let i = 0; i < result.length; i++) {\n    result[i] = {\n      index: i,\n      key: func(result[i]),\n      value: result[i]\n    };\n  } // Ensure that sorting is stable by comparing original indexes if the keys are\n  // equal.\n\n\n  result.sort((a, b) => cmp(a.key, b.key) || cmp(a.index, b.index));\n\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].value;\n  }\n\n  return result;\n}\nexport function permutations(things, cb) {\n  const tmp = Array.from(things);\n  const len = tmp.length;\n\n  function permute(i) {\n    if (i === len) {\n      cb(tmp.slice());\n      return;\n    }\n\n    const orig = tmp[i];\n\n    for (let j = i; j < len; j += 1) {\n      const pick = tmp[j];\n      tmp[j] = orig;\n      tmp[i] = pick;\n      permute(i + 1);\n      tmp[j] = pick;\n    }\n\n    tmp[i] = orig;\n  }\n\n  return permute(0);\n}","map":{"version":3,"sources":["/Users/alican/Desktop/trace/src/util.js"],"names":["cmp","a","b","sorted","iterable","key","func","x","result","Array","from","i","length","index","value","sort","permutations","things","cb","tmp","len","permute","slice","orig","j","pick"],"mappings":"AAAA,SAASA,GAAT,CAAaC,CAAb,EAAgBC,CAAhB,EAAmB;AACjB,MAAID,CAAC,KAAKC,CAAV,EAAa;AACX,WAAO,CAAP;AACD;;AACD,SAAOD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAApB;AACD;;AAED,OAAO,SAASC,MAAT,CAAgBC,QAAhB,EAA0BC,GAAG,GAAG,IAAhC,EAAsC;AAC3C,MAAIC,IAAJ;;AACA,MAAID,GAAG,KAAK,IAAZ,EAAkB;AAChBC,IAAAA,IAAI,GAAGC,CAAC,IAAIA,CAAZ;AACD,GAFD,MAEO,IAAI,OAAOF,GAAP,KAAe,UAAnB,EAA+B;AACpCC,IAAAA,IAAI,GAAGD,GAAP;AACD,GAFM,MAEA;AACLC,IAAAA,IAAI,GAAGC,CAAC,IAAIA,CAAC,CAACF,GAAD,CAAb;AACD;;AAED,QAAMG,MAAM,GAAGC,KAAK,CAACC,IAAN,CAAWN,QAAX,CAAf;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtCH,IAAAA,MAAM,CAACG,CAAD,CAAN,GAAY;AAAEE,MAAAA,KAAK,EAAEF,CAAT;AAAYN,MAAAA,GAAG,EAAEC,IAAI,CAACE,MAAM,CAACG,CAAD,CAAP,CAArB;AAAkCG,MAAAA,KAAK,EAAEN,MAAM,CAACG,CAAD;AAA/C,KAAZ;AACD,GAb0C,CAc3C;AACA;;;AACAH,EAAAA,MAAM,CAACO,IAAP,CAAY,CAACd,CAAD,EAAIC,CAAJ,KAAUF,GAAG,CAACC,CAAC,CAACI,GAAH,EAAQH,CAAC,CAACG,GAAV,CAAH,IAAqBL,GAAG,CAACC,CAAC,CAACY,KAAH,EAAUX,CAAC,CAACW,KAAZ,CAA9C;;AACA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACI,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtCH,IAAAA,MAAM,CAACG,CAAD,CAAN,GAAYH,MAAM,CAACG,CAAD,CAAN,CAAUG,KAAtB;AACD;;AACD,SAAON,MAAP;AACD;AAED,OAAO,SAASQ,YAAT,CAAsBC,MAAtB,EAA8BC,EAA9B,EAAkC;AACvC,QAAMC,GAAG,GAAGV,KAAK,CAACC,IAAN,CAAWO,MAAX,CAAZ;AACA,QAAMG,GAAG,GAAGD,GAAG,CAACP,MAAhB;;AAEA,WAASS,OAAT,CAAiBV,CAAjB,EAAoB;AAClB,QAAIA,CAAC,KAAKS,GAAV,EAAe;AACbF,MAAAA,EAAE,CAACC,GAAG,CAACG,KAAJ,EAAD,CAAF;AACA;AACD;;AAED,UAAMC,IAAI,GAAGJ,GAAG,CAACR,CAAD,CAAhB;;AACA,SAAK,IAAIa,CAAC,GAAGb,CAAb,EAAgBa,CAAC,GAAGJ,GAApB,EAAyBI,CAAC,IAAI,CAA9B,EAAiC;AAC/B,YAAMC,IAAI,GAAGN,GAAG,CAACK,CAAD,CAAhB;AACAL,MAAAA,GAAG,CAACK,CAAD,CAAH,GAASD,IAAT;AACAJ,MAAAA,GAAG,CAACR,CAAD,CAAH,GAASc,IAAT;AACAJ,MAAAA,OAAO,CAACV,CAAC,GAAG,CAAL,CAAP;AACAQ,MAAAA,GAAG,CAACK,CAAD,CAAH,GAASC,IAAT;AACD;;AACDN,IAAAA,GAAG,CAACR,CAAD,CAAH,GAASY,IAAT;AACD;;AACD,SAAOF,OAAO,CAAC,CAAD,CAAd;AACD","sourcesContent":["function cmp(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  return a < b ? -1 : 1;\n}\n\nexport function sorted(iterable, key = null) {\n  let func;\n  if (key === null) {\n    func = x => x;\n  } else if (typeof key === \"function\") {\n    func = key;\n  } else {\n    func = x => x[key];\n  }\n\n  const result = Array.from(iterable);\n  for (let i = 0; i < result.length; i++) {\n    result[i] = { index: i, key: func(result[i]), value: result[i] };\n  }\n  // Ensure that sorting is stable by comparing original indexes if the keys are\n  // equal.\n  result.sort((a, b) => cmp(a.key, b.key) || cmp(a.index, b.index));\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].value;\n  }\n  return result;\n}\n\nexport function permutations(things, cb) {\n  const tmp = Array.from(things);\n  const len = tmp.length;\n\n  function permute(i) {\n    if (i === len) {\n      cb(tmp.slice());\n      return;\n    }\n\n    const orig = tmp[i];\n    for (let j = i; j < len; j += 1) {\n      const pick = tmp[j];\n      tmp[j] = orig;\n      tmp[i] = pick;\n      permute(i + 1);\n      tmp[j] = pick;\n    }\n    tmp[i] = orig;\n  }\n  return permute(0);\n}"]},"metadata":{},"sourceType":"module"}