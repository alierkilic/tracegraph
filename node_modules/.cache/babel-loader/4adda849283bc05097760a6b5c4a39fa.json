{"ast":null,"code":"import { sorted } from \"./util\";\nimport { Rect, flippedRect } from \"./rect\";\nimport calc from \"./calc\";\nexport function traceCurve() {\n  return function ({\n    points,\n    horizontal,\n    smoothness\n  }) {\n    return points.map(([x1, y1], index) => {\n      if (index === 0) {\n        return `M ${x1} ${y1}`;\n      }\n\n      const [x0, y0] = points[index - 1];\n      const dx = smoothness * (horizontal ? x1 - x0 : 0);\n      const dy = smoothness * (horizontal ? 0 : y1 - y0);\n      return `C ${x0 + dx} ${y0 + dy},  ${x1 - dx} ${y1 - dy}, ${x1} ${y1}`;\n    }).join(\" \");\n  };\n}\nexport function nodeGradient(node) {\n  const {\n    horizontal,\n    traceStops\n  } = node;\n  const start = Math.min(...traceStops.map(s => s.start));\n  const end = Math.max(...traceStops.map(s => s.end));\n  const stops = [];\n  traceStops.forEach(s => {\n    stops.push({\n      traceIndex: s.traceIndex,\n      offset: (s.start - start) / (end - start)\n    }, {\n      traceIndex: s.traceIndex,\n      offset: (s.end - start) / (end - start)\n    });\n  });\n  return {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: horizontal ? 0 : start,\n    y1: horizontal ? start : 0,\n    x2: horizontal ? 0 : end,\n    y2: horizontal ? end : 0,\n    stops: sorted(stops, \"offset\")\n  };\n}\nexport function genUID() {\n  const base = window.location.href.replace(/#.*/, \"\");\n\n  for (;;) {\n    const id = `uid-${Math.random()}`;\n\n    if (!document.getElementById(id)) {\n      const attr = `url(${base}#${id})`;\n      return {\n        id,\n\n        toString() {\n          return attr;\n        }\n\n      };\n    }\n  }\n}\n\nfunction verticalGraph(origTraces, options) {\n  const horizontal = Boolean(options.horizontal());\n  const levelMargin = options.levelMargin();\n  const traceSmoothness = options.traceSmoothness();\n  const traceWidths = origTraces.map((trace, index) => {\n    return options.traceWidth(trace, index, origTraces);\n  });\n  const {\n    traces,\n    levels\n  } = calc(origTraces, options);\n  const nodeMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        traceWidth: node.hops.reduce((total, hop) => total + traceWidths[hop.traceIndex], 0)\n      };\n\n      if (!node.virtual) {\n        const [width, height] = options.nodeSize({\n          hops: node.hops.map(hop => hop.origHop),\n          horizontal: Boolean(horizontal)\n        });\n        nm.width = width;\n        nm.height = height;\n      }\n\n      nm.width = Math.max(nm.width, nm.traceWidth);\n      nodeMetrics.set(node, nm);\n    });\n  });\n  let maxNodeWidth = 0;\n  nodeMetrics.forEach(nm => {\n    maxNodeWidth = Math.max(nm.width, maxNodeWidth);\n  });\n  const sortedTraceWidths = sorted(traceWidths);\n  levels.forEach(nodes => {\n    let width = maxNodeWidth;\n\n    if (nodes.length >= 2) {\n      const leeway = sortedTraceWidths.slice(nodes.length - 1).reduce((acc, cur) => acc + cur, 0);\n      width = (maxNodeWidth + leeway) / 2;\n    }\n\n    nodes.forEach((node, index) => {\n      nodeMetrics.get(node).x += (index - (nodes.length - 1) / 2) * width;\n    });\n    let overlaps = 0;\n    let maxOverlaps = 0;\n    nodes.forEach(node => {\n      if (node.virtual) {\n        overlaps = 0;\n      } else {\n        overlaps += 1;\n        maxOverlaps = Math.max(overlaps, maxOverlaps);\n      }\n    });\n    nodes.forEach((node, index) => {\n      let y = 0;\n\n      if (maxOverlaps >= 2 && index % 2 === 0) {\n        const left = index === 0 ? 0 : nodeMetrics.get(nodes[index - 1]).height;\n        const right = index === nodes.length - 1 ? 0 : nodeMetrics.get(nodes[index + 1]).height;\n        y += Math.max(left, right);\n      }\n\n      nodeMetrics.get(node).y = y;\n    });\n  });\n  const hopMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      let traceOffset = 0;\n      node.hops.forEach(hop => {\n        const traceWidth = traceWidths[hop.traceIndex];\n        hopMetrics.set(hop, {\n          traceWidth,\n          traceOffset,\n          x: nm.x + traceOffset + traceWidth / 2 - nm.traceWidth / 2,\n          top: 0,\n          bottom: 0\n        });\n        traceOffset += traceWidth;\n      });\n    });\n  });\n  traces.forEach(trace => {\n    const hops = trace.hops;\n\n    for (let i = 1; i < hops.length; i++) {\n      const leftHop = hops[i - 1];\n      const left = hopMetrics.get(leftHop);\n      const right = hopMetrics.get(hops[i]);\n      const lnm = nodeMetrics.get(leftHop.node);\n      const dy = 3 / 2 * (1 - traceSmoothness) * (2 * levelMargin);\n      const dx = 3 / 2 * (right.x - left.x);\n      const normalLen = Math.sqrt(dx * dx + dy * dy);\n      let nudge = 0;\n\n      if (normalLen > 0) {\n        // Correction\n        const xfix = 1 - dy / normalLen;\n        const slope = dx !== 0 ? dy / dx : 0;\n        const offset = dx / normalLen - slope * xfix;\n\n        if (dx > 0) {\n          nudge = (lnm.traceWidth - left.traceOffset - left.traceWidth) * offset;\n        } else {\n          nudge = -left.traceOffset * offset;\n        }\n      }\n\n      left.bottom = nudge;\n      right.top = nudge;\n    }\n  });\n  const levelMetrics = new Map();\n  let totalHeight = 0;\n  levels.forEach((nodes, level) => {\n    let top = 0;\n    nodes.forEach(node => {\n      node.hops.forEach(hop => {\n        const hm = hopMetrics.get(hop);\n        top = Math.max(hm.top, top);\n      });\n    });\n    let height = 0;\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      height = Math.max(height, nm.height + nm.y);\n    });\n    levelMetrics.set(level, {\n      top,\n      height,\n      y: totalHeight\n    });\n    totalHeight += height + top + 2 * levelMargin;\n  });\n  const result = {\n    nodes: [],\n    traces: [],\n    bounds: null\n  };\n  traces.forEach((trace, traceIndex) => {\n    const sections = [];\n    const hops = trace.hops;\n    hops.forEach((hop, index) => {\n      if (hop.virtual) {\n        return;\n      }\n\n      let cut = index - 1;\n\n      while (cut >= 0 && hops[cut].virtual) {\n        cut--;\n      }\n\n      if (cut >= 0) {\n        sections.push({\n          hops: hops.slice(cut, index + 1),\n          defined: hops[cut].defined && hop.defined\n        });\n      }\n    });\n    const joinedSections = sections.splice(0, 1);\n    sections.forEach(section => {\n      const joined = joinedSections[joinedSections.length - 1];\n\n      if (Boolean(section.defined) === Boolean(joined.defined)) {\n        joined.hops.push(...section.hops.slice(1));\n      } else {\n        joinedSections.push(section);\n      }\n    });\n    const pointSections = joinedSections.map(({\n      hops,\n      defined\n    }) => {\n      const points = [];\n      hops.forEach((right, index) => {\n        const rhm = hopMetrics.get(right);\n        const rnm = nodeMetrics.get(right.node);\n        const rlm = levelMetrics.get(right.level);\n\n        if (index === 0) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n          return;\n        }\n\n        const lhm = hopMetrics.get(hops[index - 1]);\n        const llm = levelMetrics.get(hops[index - 1].level);\n        const y = llm.y + llm.top + llm.height + lhm.bottom;\n        points.push([lhm.x, y]);\n        points.push([rhm.x, y + 2 * levelMargin]);\n\n        if (index === hops.length - 1) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n        }\n      });\n      return {\n        points,\n        defined\n      };\n    });\n    pointSections.forEach(section => {\n      result.traces.push({\n        index: traceIndex,\n        width: traceWidths[traceIndex],\n        hops: trace.hops.map(hop => hop.origHop),\n        defined: section.defined,\n        points: section.points,\n        smoothness: traceSmoothness,\n        horizontal: horizontal\n      });\n    });\n  });\n  let left = levels.length === 0 ? 0 : Infinity;\n  let right = levels.length === 0 ? 0 : -Infinity;\n  let top = levels.length === 0 ? 0 : Infinity;\n  let bottom = levels.length === 0 ? 0 : -Infinity;\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      const lm = levelMetrics.get(node.level);\n      const x0 = nm.x - nm.width / 2;\n      const x1 = nm.x + nm.width / 2;\n      const y0 = lm.y + lm.top + nm.y;\n      const y1 = y0 + nm.height;\n      left = Math.min(x0, left);\n      right = Math.max(x1, right);\n      top = Math.min(y0, top);\n      bottom = Math.max(y1, bottom);\n\n      if (node.virtual) {\n        return;\n      }\n\n      let offset = (x0 + x1) / 2 - nm.traceWidth / 2;\n      const traceStops = node.hops.map(hop => {\n        const start = offset;\n        offset += traceWidths[hop.traceIndex];\n        return {\n          start,\n          end: offset,\n          traceIndex: hop.traceIndex\n        };\n      });\n      result.nodes.push({\n        bounds: new Rect(x0, y0, x1, y1),\n        horizontal,\n        hops: node.hops.map(hop => hop.origHop),\n        traceIndexes: node.hops.map(hop => hop.traceIndex),\n        traceStops\n      });\n    });\n  });\n  result.bounds = new Rect(left, top, right, bottom);\n  return result;\n}\n\nexport function tracegraph() {\n  const values = {\n    horizontal: false,\n    traceWidth: () => 1,\n    traceSmoothness: 0.5,\n    levelMargin: 10,\n    hopLevel: (hop, index) => index,\n    hopDefined: () => true,\n    nodeSize: () => [10, 10],\n    nodeId: (hop, hopIndex, trace, traceIndex) => `${traceIndex}-${hopIndex}`\n  };\n\n  function graph(traces) {\n    const horizontal = options.horizontal();\n\n    if (horizontal) {\n      const nodeSize = options.nodeSize;\n\n      options.nodeSize = (...args) => {\n        const [w, h] = nodeSize(...args);\n        return [h, w];\n      };\n    }\n\n    const result = verticalGraph(traces, options);\n\n    if (!horizontal) {\n      return result;\n    }\n\n    return {\n      bounds: flippedRect(result.bounds),\n      traces: result.traces.map(trace => ({ ...trace,\n        points: trace.points.map(([x, y]) => [y, x])\n      })),\n      nodes: result.nodes.map(node => ({ ...node,\n        bounds: flippedRect(node.bounds)\n      }))\n    };\n  }\n\n  const options = {};\n  Object.keys(values).forEach(key => {\n    graph[key] = function (value) {\n      if (arguments.length === 0) {\n        return values[key];\n      }\n\n      values[key] = value;\n      options[key] = typeof value === \"function\" ? value : () => value;\n      return graph;\n    };\n\n    graph[key](values[key]);\n  });\n  return graph;\n}","map":{"version":3,"sources":["/Users/alican/Desktop/trace/src/mytrec.js"],"names":["sorted","Rect","flippedRect","calc","traceCurve","points","horizontal","smoothness","map","x1","y1","index","x0","y0","dx","dy","join","nodeGradient","node","traceStops","start","Math","min","s","end","max","stops","forEach","push","traceIndex","offset","gradientUnits","x2","y2","genUID","base","window","location","href","replace","id","random","document","getElementById","attr","toString","verticalGraph","origTraces","options","Boolean","levelMargin","traceSmoothness","traceWidths","trace","traceWidth","traces","levels","nodeMetrics","Map","nodes","nm","x","y","width","height","hops","reduce","total","hop","virtual","nodeSize","origHop","set","maxNodeWidth","sortedTraceWidths","length","leeway","slice","acc","cur","get","overlaps","maxOverlaps","left","right","hopMetrics","traceOffset","top","bottom","i","leftHop","lnm","normalLen","sqrt","nudge","xfix","slope","levelMetrics","totalHeight","level","hm","result","bounds","sections","cut","defined","joinedSections","splice","section","joined","pointSections","rhm","rnm","rlm","lhm","llm","Infinity","lm","traceIndexes","tracegraph","values","hopLevel","hopDefined","nodeId","hopIndex","graph","args","w","h","Object","keys","key","value","arguments"],"mappings":"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","sourcesContent":["import { sorted } from \"./util\";\nimport { Rect, flippedRect } from \"./rect\";\nimport calc from \"./calc\";\n\nexport function traceCurve() {\n  return function({ points, horizontal, smoothness }) {\n    return points\n      .map(([x1, y1], index) => {\n        if (index === 0) {\n          return `M ${x1} ${y1}`;\n        }\n        const [x0, y0] = points[index - 1];\n        const dx = smoothness * (horizontal ? x1 - x0 : 0);\n        const dy = smoothness * (horizontal ? 0 : y1 - y0);\n        return `C ${x0 + dx} ${y0 + dy},  ${x1 - dx} ${y1 - dy}, ${x1} ${y1}`;\n      })\n      .join(\" \");\n  };\n}\n\nexport function nodeGradient(node) {\n  const { horizontal, traceStops } = node;\n\n  const start = Math.min(...traceStops.map(s => s.start));\n  const end = Math.max(...traceStops.map(s => s.end));\n\n  const stops = [];\n  traceStops.forEach(s => {\n    stops.push(\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.start - start) / (end - start)\n      },\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.end - start) / (end - start)\n      }\n    );\n  });\n\n  return {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: horizontal ? 0 : start,\n    y1: horizontal ? start : 0,\n    x2: horizontal ? 0 : end,\n    y2: horizontal ? end : 0,\n    stops: sorted(stops, \"offset\")\n  };\n}\n\nexport function genUID() {\n  const base = window.location.href.replace(/#.*/, \"\");\n\n  for (;;) {\n    const id = `uid-${Math.random()}`;\n    if (!document.getElementById(id)) {\n      const attr = `url(${base}#${id})`;\n      return {\n        id,\n        toString() {\n          return attr;\n        }\n      };\n    }\n  }\n}\n\nfunction verticalGraph(origTraces, options) {\n  const horizontal = Boolean(options.horizontal());\n  const levelMargin = options.levelMargin();\n  const traceSmoothness = options.traceSmoothness();\n  const traceWidths = origTraces.map((trace, index) => {\n    return options.traceWidth(trace, index, origTraces);\n  });\n\n  const { traces, levels } = calc(origTraces, options);\n\n  const nodeMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        traceWidth: node.hops.reduce(\n          (total, hop) => total + traceWidths[hop.traceIndex],\n          0\n        )\n      };\n      if (!node.virtual) {\n        const [width, height] = options.nodeSize({\n          hops: node.hops.map(hop => hop.origHop),\n          horizontal: Boolean(horizontal)\n        });\n        nm.width = width;\n        nm.height = height;\n      }\n      nm.width = Math.max(nm.width, nm.traceWidth);\n      nodeMetrics.set(node, nm);\n    });\n  });\n\n  let maxNodeWidth = 0;\n  nodeMetrics.forEach(nm => {\n    maxNodeWidth = Math.max(nm.width, maxNodeWidth);\n  });\n  const sortedTraceWidths = sorted(traceWidths);\n  levels.forEach(nodes => {\n    let width = maxNodeWidth;\n    if (nodes.length >= 2) {\n      const leeway = sortedTraceWidths\n        .slice(nodes.length - 1)\n        .reduce((acc, cur) => acc + cur, 0);\n      width = (maxNodeWidth + leeway) / 2;\n    }\n    nodes.forEach((node, index) => {\n      nodeMetrics.get(node).x += (index - (nodes.length - 1) / 2) * width;\n    });\n\n    let overlaps = 0;\n    let maxOverlaps = 0;\n    nodes.forEach(node => {\n      if (node.virtual) {\n        overlaps = 0;\n      } else {\n        overlaps += 1;\n        maxOverlaps = Math.max(overlaps, maxOverlaps);\n      }\n    });\n    nodes.forEach((node, index) => {\n      let y = 0;\n      if (maxOverlaps >= 2 && index % 2 === 0) {\n        const left = index === 0 ? 0 : nodeMetrics.get(nodes[index - 1]).height;\n        const right =\n          index === nodes.length - 1\n            ? 0\n            : nodeMetrics.get(nodes[index + 1]).height;\n        y += Math.max(left, right);\n      }\n      nodeMetrics.get(node).y = y;\n    });\n  });\n\n  const hopMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n\n      let traceOffset = 0;\n      node.hops.forEach(hop => {\n        const traceWidth = traceWidths[hop.traceIndex];\n        hopMetrics.set(hop, {\n          traceWidth,\n          traceOffset,\n          x: nm.x + traceOffset + traceWidth / 2 - nm.traceWidth / 2,\n          top: 0,\n          bottom: 0\n        });\n        traceOffset += traceWidth;\n      });\n    });\n  });\n\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 1; i < hops.length; i++) {\n      const leftHop = hops[i - 1];\n      const left = hopMetrics.get(leftHop);\n      const right = hopMetrics.get(hops[i]);\n      const lnm = nodeMetrics.get(leftHop.node);\n\n      const dy = (3 / 2) * (1 - traceSmoothness) * (2 * levelMargin);\n      const dx = (3 / 2) * (right.x - left.x);\n      const normalLen = Math.sqrt(dx * dx + dy * dy);\n\n      let nudge = 0;\n      if (normalLen > 0) {\n        // Correction\n        const xfix = 1 - dy / normalLen;\n        const slope = dx !== 0 ? dy / dx : 0;\n        const offset = dx / normalLen - slope * xfix;\n\n        if (dx > 0) {\n          nudge =\n            (lnm.traceWidth - left.traceOffset - left.traceWidth) * offset;\n        } else {\n          nudge = -left.traceOffset * offset;\n        }\n      }\n      left.bottom = nudge;\n      right.top = nudge;\n    }\n  });\n\n  const levelMetrics = new Map();\n  let totalHeight = 0;\n  levels.forEach((nodes, level) => {\n    let top = 0;\n    nodes.forEach(node => {\n      node.hops.forEach(hop => {\n        const hm = hopMetrics.get(hop);\n        top = Math.max(hm.top, top);\n      });\n    });\n\n    let height = 0;\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      height = Math.max(height, nm.height + nm.y);\n    });\n\n    levelMetrics.set(level, {\n      top,\n      height,\n      y: totalHeight\n    });\n    totalHeight += height + top + 2 * levelMargin;\n  });\n\n  const result = {\n    nodes: [],\n    traces: [],\n    bounds: null\n  };\n\n  traces.forEach((trace, traceIndex) => {\n    const sections = [];\n\n    const hops = trace.hops;\n    hops.forEach((hop, index) => {\n      if (hop.virtual) {\n        return;\n      }\n\n      let cut = index - 1;\n      while (cut >= 0 && hops[cut].virtual) {\n        cut--;\n      }\n      if (cut >= 0) {\n        sections.push({\n          hops: hops.slice(cut, index + 1),\n          defined: hops[cut].defined && hop.defined\n        });\n      }\n    });\n\n    const joinedSections = sections.splice(0, 1);\n    sections.forEach(section => {\n      const joined = joinedSections[joinedSections.length - 1];\n      if (Boolean(section.defined) === Boolean(joined.defined)) {\n        joined.hops.push(...section.hops.slice(1));\n      } else {\n        joinedSections.push(section);\n      }\n    });\n\n    const pointSections = joinedSections.map(({ hops, defined }) => {\n      const points = [];\n      hops.forEach((right, index) => {\n        const rhm = hopMetrics.get(right);\n        const rnm = nodeMetrics.get(right.node);\n        const rlm = levelMetrics.get(right.level);\n        if (index === 0) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n          return;\n        }\n\n        const lhm = hopMetrics.get(hops[index - 1]);\n        const llm = levelMetrics.get(hops[index - 1].level);\n        const y = llm.y + llm.top + llm.height + lhm.bottom;\n        points.push([lhm.x, y]);\n        points.push([rhm.x, y + 2 * levelMargin]);\n\n        if (index === hops.length - 1) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n        }\n      });\n      return { points, defined };\n    });\n\n    pointSections.forEach(section => {\n      result.traces.push({\n        index: traceIndex,\n        width: traceWidths[traceIndex],\n        hops: trace.hops.map(hop => hop.origHop),\n        defined: section.defined,\n        points: section.points,\n        smoothness: traceSmoothness,\n        horizontal: horizontal\n      });\n    });\n  });\n\n  let left = levels.length === 0 ? 0 : Infinity;\n  let right = levels.length === 0 ? 0 : -Infinity;\n  let top = levels.length === 0 ? 0 : Infinity;\n  let bottom = levels.length === 0 ? 0 : -Infinity;\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      const lm = levelMetrics.get(node.level);\n      const x0 = nm.x - nm.width / 2;\n      const x1 = nm.x + nm.width / 2;\n      const y0 = lm.y + lm.top + nm.y;\n      const y1 = y0 + nm.height;\n\n      left = Math.min(x0, left);\n      right = Math.max(x1, right);\n      top = Math.min(y0, top);\n      bottom = Math.max(y1, bottom);\n      if (node.virtual) {\n        return;\n      }\n\n      let offset = (x0 + x1) / 2 - nm.traceWidth / 2;\n      const traceStops = node.hops.map(hop => {\n        const start = offset;\n        offset += traceWidths[hop.traceIndex];\n        return {\n          start,\n          end: offset,\n          traceIndex: hop.traceIndex\n        };\n      });\n      result.nodes.push({\n        bounds: new Rect(x0, y0, x1, y1),\n        horizontal,\n        hops: node.hops.map(hop => hop.origHop),\n        traceIndexes: node.hops.map(hop => hop.traceIndex),\n        traceStops\n      });\n    });\n  });\n\n  result.bounds = new Rect(left, top, right, bottom);\n  return result;\n}\n\nexport function tracegraph() {\n  const values = {\n    horizontal: false,\n    traceWidth: () => 1,\n    traceSmoothness: 0.5,\n    levelMargin: 10,\n    hopLevel: (hop, index) => index,\n    hopDefined: () => true,\n    nodeSize: () => [10, 10],\n    nodeId: (hop, hopIndex, trace, traceIndex) => `${traceIndex}-${hopIndex}`\n  };\n\n  function graph(traces) {\n    const horizontal = options.horizontal();\n    if (horizontal) {\n      const nodeSize = options.nodeSize;\n      options.nodeSize = (...args) => {\n        const [w, h] = nodeSize(...args);\n        return [h, w];\n      };\n    }\n\n    const result = verticalGraph(traces, options);\n    if (!horizontal) {\n      return result;\n    }\n    return {\n      bounds: flippedRect(result.bounds),\n      traces: result.traces.map(trace => ({\n        ...trace,\n        points: trace.points.map(([x, y]) => [y, x])\n      })),\n      nodes: result.nodes.map(node => ({\n        ...node,\n        bounds: flippedRect(node.bounds)\n      }))\n    };\n  }\n\n  const options = {};\n  Object.keys(values).forEach(key => {\n    graph[key] = function(value) {\n      if (arguments.length === 0) {\n        return values[key];\n      }\n      values[key] = value;\n      options[key] = typeof value === \"function\" ? value : () => value;\n      return graph;\n    };\n    graph[key](values[key]);\n  });\n  return graph;\n}"]},"metadata":{},"sourceType":"module"}