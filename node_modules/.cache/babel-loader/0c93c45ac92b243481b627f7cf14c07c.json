{"ast":null,"code":"function t(t, n) {\n  return t === n ? 0 : t < n ? -1 : 1;\n}\n\nfunction n(n, e) {\n  var r;\n  void 0 === e && (e = null), r = null === e ? function (t) {\n    return t;\n  } : \"function\" == typeof e ? e : function (t) {\n    return t[e];\n  };\n\n  for (var o = Array.from(n), i = 0; i < o.length; i++) o[i] = {\n    index: i,\n    key: r(o[i]),\n    value: o[i]\n  };\n\n  o.sort(function (n, e) {\n    return t(n.key, e.key) || t(n.index, e.index);\n  });\n\n  for (var a = 0; a < o.length; a++) o[a] = o[a].value;\n\n  return o;\n}\n\nvar e = function (t, n, e, r) {\n  this._l = t, this._r = e, this._t = n, this._b = r;\n},\n    r = {\n  left: {\n    configurable: !0\n  },\n  top: {\n    configurable: !0\n  },\n  right: {\n    configurable: !0\n  },\n  bottom: {\n    configurable: !0\n  },\n  x: {\n    configurable: !0\n  },\n  y: {\n    configurable: !0\n  },\n  cx: {\n    configurable: !0\n  },\n  cy: {\n    configurable: !0\n  },\n  width: {\n    configurable: !0\n  },\n  height: {\n    configurable: !0\n  }\n};\n\nfunction o(t) {\n  return new e(t.top, t.left, t.bottom, t.right);\n}\n\nfunction i(t) {\n  var e = new Map(),\n      r = t.map(function (t) {\n    var n = t.hops.map(function (t) {\n      var n = (t.virtual ? \"virtual\" : \"real\") + \"-\" + t.nodeId,\n          r = e.get(n) || {\n        id: n,\n        virtual: t.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      e.set(n, r);\n      var o = Object.assign({}, t, {\n        nodeId: n,\n        node: r\n      });\n      return r.hops.push(o), r.traceIndexes.add(o.traceIndex), o;\n    });\n    return Object.assign({}, t, {\n      hops: n\n    });\n  });\n  r.forEach(function (t) {\n    for (var e = n(t.hops, \"level\"), r = 1; r < e.length; r++) {\n      var o = e[r - 1],\n          i = e[r];\n      i.level === o.level + 1 && (i.node.prev.add(o.node), o.node.next.add(i.node));\n    }\n  });\n  var o = new Map();\n  return e.forEach(function (t) {\n    t.level = function t(n, e) {\n      if (e.has(n)) return e.get(n);\n      var r = n.hops.reduce(function (t, n) {\n        return Math.max(t, n.level);\n      }, 0);\n      return n.prev.forEach(function (n) {\n        r = Math.max(t(n, e) + 1, r);\n      }), e.set(n, r), r;\n    }(t, o), t.hops.forEach(function (n) {\n      return n.level = t.level;\n    });\n  }), r;\n}\n\nfunction a(t) {\n  var e = new Map();\n  return n(t, \"level\").map(function (t) {\n    var n = t.nodeId,\n        r = e.get(n) || 0;\n    return e.set(n, r + 1), Object.assign({}, t, {\n      nodeId: r + \"-\" + n\n    });\n  });\n}\n\nfunction u(t, e) {\n  var r = new Map();\n  return t.forEach(function (t) {\n    var n = Infinity;\n    t.traceIndexes.forEach(function (t) {\n      n = Math.min(n, e[t]);\n    }), r.set(t, n);\n  }), n(t, function (t) {\n    return r.get(t);\n  });\n}\n\nfunction f(t, e) {\n  return n(t, function (t) {\n    return e[t.traceIndex];\n  });\n}\n\nfunction c(t, e) {\n  var r,\n      o,\n      c,\n      h,\n      s = i(function (t) {\n    return t.map(function (t) {\n      var e = [],\n          r = n(t.hops, \"level\");\n      return r.forEach(function (t, n) {\n        if (n > 0) for (var o = r[n - 1], i = o.level + 1; i < t.level; i++) e.push(Object.assign({}, o, {\n          level: i,\n          virtual: !0,\n          nodeId: i + \"-\" + o.nodeId\n        }));\n        e.push(Object.assign({}, t, {\n          nodeId: t.level + \"-\" + t.nodeId\n        }));\n      }), Object.assign({}, t, {\n        hops: e\n      });\n    });\n  }(i(t.map(function (n, r) {\n    return {\n      hops: a(n.hops.map(function (o, i) {\n        return {\n          traceIndex: r,\n          hopIndex: i,\n          nodeId: e.nodeId(o, i, n, r, t),\n          node: null,\n          defined: e.hopDefined(o, i, n, r, t),\n          level: e.hopLevel(o, i, n, r, t),\n          virtual: !1,\n          origHop: o\n        };\n      }))\n    };\n  })))).map(function (t) {\n    return Object.assign({}, t, {\n      hops: n(t.hops, \"level\")\n    });\n  }),\n      d = function (t) {\n    var n = 0;\n    t.forEach(function (t) {\n      t.hops.forEach(function (t) {\n        n = Math.max(n, t.level);\n      });\n    });\n\n    for (var e = new Array(n + 1), r = 0; r < e.length; r++) e[r] = new Set();\n\n    return t.forEach(function (t) {\n      t.hops.forEach(function (t) {\n        e[t.level].add(t.node);\n      });\n    }), e.map(function (t) {\n      return Array.from(t);\n    });\n  }(s),\n      l = [],\n      p = Infinity;\n\n  return r = s.map(function (t, n) {\n    return n;\n  }), o = function (t) {\n    var n = function (t, n, e) {\n      var r = new Map();\n      n.forEach(function (t) {\n        var n = 0;\n        u(t, e).forEach(function (t) {\n          f(t.hops, e).forEach(function (t) {\n            r.set(t, n), n += 1;\n          });\n        });\n      });\n      var o = 0;\n      return t.forEach(function (t) {\n        for (var n = t.hops, e = 0; e < n.length - 1; e++) o += Math.abs(r.get(n[e]) - r.get(n[e + 1]));\n      }), o;\n    }(s, d, t);\n\n    n < p && (p = n, l = t);\n  }, c = Array.from(r), h = c.length, function t(n) {\n    if (n !== h) {\n      for (var e = c[n], r = n; r < h; r += 1) {\n        var i = c[r];\n        c[r] = e, c[n] = i, t(n + 1), c[r] = i;\n      }\n\n      c[n] = e;\n    } else o(c.slice());\n  }(0), d.forEach(function (t) {\n    t.forEach(function (t) {\n      t.hops = f(t.hops, l);\n    });\n  }), {\n    traces: s,\n    levels: d.map(function (t) {\n      return u(t, l);\n    })\n  };\n}\n\nfunction h() {\n  return function (t) {\n    var n = t.points,\n        e = t.horizontal,\n        r = t.smoothness;\n    return n.map(function (t, o) {\n      var i = t[0],\n          a = t[1];\n      if (0 === o) return \"M \" + i + \" \" + a;\n      var u = n[o - 1],\n          f = u[0],\n          c = u[1],\n          h = r * (e ? i - f : 0),\n          s = r * (e ? 0 : a - c);\n      return \"C \" + (f + h) + \" \" + (c + s) + \",  \" + (i - h) + \" \" + (a - s) + \", \" + i + \" \" + a;\n    }).join(\" \");\n  };\n}\n\nfunction s(t) {\n  var e = t.horizontal,\n      r = t.traceStops,\n      o = Math.min.apply(Math, r.map(function (t) {\n    return t.start;\n  })),\n      i = Math.max.apply(Math, r.map(function (t) {\n    return t.end;\n  })),\n      a = [];\n  return r.forEach(function (t) {\n    a.push({\n      traceIndex: t.traceIndex,\n      offset: (t.start - o) / (i - o)\n    }, {\n      traceIndex: t.traceIndex,\n      offset: (t.end - o) / (i - o)\n    });\n  }), {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: e ? 0 : o,\n    y1: e ? o : 0,\n    x2: e ? 0 : i,\n    y2: e ? i : 0,\n    stops: n(a, \"offset\")\n  };\n}\n\nfunction d() {\n  for (var t = window.location.href.replace(/#.*/, \"\");;) {\n    var n = \"uid-\" + Math.random();\n\n    if (!document.getElementById(n)) {\n      var e = \"url(\" + t + \"#\" + n + \")\";\n      return {\n        id: n,\n        toString: function () {\n          return e;\n        }\n      };\n    }\n  }\n}\n\nfunction l() {\n  var t = {\n    horizontal: !1,\n    traceWidth: function () {\n      return 1;\n    },\n    traceSmoothness: .5,\n    levelMargin: 10,\n    hopLevel: function (t, n) {\n      return n;\n    },\n    hopDefined: function () {\n      return !0;\n    },\n    nodeSize: function () {\n      return [10, 10];\n    },\n    nodeId: function (t, n, e, r) {\n      return r + \"-\" + n;\n    }\n  };\n\n  function r(t) {\n    var r = i.horizontal();\n\n    if (r) {\n      var a = i.nodeSize;\n\n      i.nodeSize = function () {\n        for (var t = [], n = arguments.length; n--;) t[n] = arguments[n];\n\n        var e = a.apply(void 0, t);\n        return [e[1], e[0]];\n      };\n    }\n\n    var u = function (t, r) {\n      var o = Boolean(r.horizontal()),\n          i = r.levelMargin(),\n          a = r.traceSmoothness(),\n          u = t.map(function (n, e) {\n        return r.traceWidth(n, e, t);\n      }),\n          f = c(t, r),\n          h = f.traces,\n          s = f.levels,\n          d = new Map();\n      s.forEach(function (t) {\n        t.forEach(function (t) {\n          var n = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            traceWidth: t.hops.reduce(function (t, n) {\n              return t + u[n.traceIndex];\n            }, 0)\n          };\n\n          if (!t.virtual) {\n            var e = r.nodeSize({\n              hops: t.hops.map(function (t) {\n                return t.origHop;\n              }),\n              horizontal: Boolean(o)\n            }),\n                i = e[1];\n            n.width = e[0], n.height = i;\n          }\n\n          n.width = Math.max(n.width, n.traceWidth), d.set(t, n);\n        });\n      });\n      var l = 0;\n      d.forEach(function (t) {\n        l = Math.max(t.width, l);\n      });\n      var p = n(u);\n      s.forEach(function (t) {\n        var n = l;\n\n        if (t.length >= 2) {\n          var e = p.slice(t.length - 1).reduce(function (t, n) {\n            return t + n;\n          }, 0);\n          n = (l + e) / 2;\n        }\n\n        t.forEach(function (e, r) {\n          d.get(e).x += (r - (t.length - 1) / 2) * n;\n        });\n        var r = 0,\n            o = 0;\n        t.forEach(function (t) {\n          t.virtual ? r = 0 : (r += 1, o = Math.max(r, o));\n        }), t.forEach(function (n, e) {\n          var r = 0;\n\n          if (o >= 2 && e % 2 == 0) {\n            var i = 0 === e ? 0 : d.get(t[e - 1]).height,\n                a = e === t.length - 1 ? 0 : d.get(t[e + 1]).height;\n            r += Math.max(i, a);\n          }\n\n          d.get(n).y = r;\n        });\n      });\n      var v = new Map();\n      s.forEach(function (t) {\n        t.forEach(function (t) {\n          var n = d.get(t),\n              e = 0;\n          t.hops.forEach(function (t) {\n            var r = u[t.traceIndex];\n            v.set(t, {\n              traceWidth: r,\n              traceOffset: e,\n              x: n.x + e + r / 2 - n.traceWidth / 2,\n              top: 0,\n              bottom: 0\n            }), e += r;\n          });\n        });\n      }), h.forEach(function (t) {\n        for (var n = t.hops, e = 1; e < n.length; e++) {\n          var r = n[e - 1],\n              o = v.get(r),\n              u = v.get(n[e]),\n              f = d.get(r.node),\n              c = 1.5 * (1 - a) * (2 * i),\n              h = 1.5 * (u.x - o.x),\n              s = Math.sqrt(h * h + c * c),\n              l = 0;\n\n          if (s > 0) {\n            var p = h / s - (0 !== h ? c / h : 0) * (1 - c / s);\n            l = h > 0 ? (f.traceWidth - o.traceOffset - o.traceWidth) * p : -o.traceOffset * p;\n          }\n\n          o.bottom = l, u.top = l;\n        }\n      });\n      var g = new Map(),\n          m = 0;\n      s.forEach(function (t, n) {\n        var e = 0;\n        t.forEach(function (t) {\n          t.hops.forEach(function (t) {\n            var n = v.get(t);\n            e = Math.max(n.top, e);\n          });\n        });\n        var r = 0;\n        t.forEach(function (t) {\n          var n = d.get(t);\n          r = Math.max(r, n.height + n.y);\n        }), g.set(n, {\n          top: e,\n          height: r,\n          y: m\n        }), m += r + e + 2 * i;\n      });\n      var x = {\n        nodes: [],\n        traces: [],\n        bounds: null\n      };\n      h.forEach(function (t, n) {\n        var e = [],\n            r = t.hops;\n        r.forEach(function (t, n) {\n          if (!t.virtual) {\n            for (var o = n - 1; o >= 0 && r[o].virtual;) o--;\n\n            o >= 0 && e.push({\n              hops: r.slice(o, n + 1),\n              defined: r[o].defined && t.defined\n            });\n          }\n        });\n        var f = e.splice(0, 1);\n        e.forEach(function (t) {\n          var n,\n              e = f[f.length - 1];\n          Boolean(t.defined) === Boolean(e.defined) ? (n = e.hops).push.apply(n, t.hops.slice(1)) : f.push(t);\n        }), f.map(function (t) {\n          var n = t.hops,\n              e = t.defined,\n              r = [];\n          return n.forEach(function (t, e) {\n            var o = v.get(t),\n                a = d.get(t.node),\n                u = g.get(t.level);\n\n            if (0 !== e) {\n              var f = v.get(n[e - 1]),\n                  c = g.get(n[e - 1].level),\n                  h = c.y + c.top + c.height + f.bottom;\n              r.push([f.x, h]), r.push([o.x, h + 2 * i]), e === n.length - 1 && r.push([o.x, u.y + u.top + a.y + a.height / 2]);\n            } else r.push([o.x, u.y + u.top + a.y + a.height / 2]);\n          }), {\n            points: r,\n            defined: e\n          };\n        }).forEach(function (e) {\n          x.traces.push({\n            index: n,\n            width: u[n],\n            hops: t.hops.map(function (t) {\n              return t.origHop;\n            }),\n            defined: e.defined,\n            points: e.points,\n            smoothness: a,\n            horizontal: o\n          });\n        });\n      });\n      var E = 0 === s.length ? 0 : Infinity,\n          b = 0 === s.length ? 0 : -Infinity,\n          y = 0 === s.length ? 0 : Infinity,\n          I = 0 === s.length ? 0 : -Infinity;\n      return s.forEach(function (t) {\n        t.forEach(function (t) {\n          var n = d.get(t),\n              r = g.get(t.level),\n              i = n.x - n.width / 2,\n              a = n.x + n.width / 2,\n              f = r.y + r.top + n.y,\n              c = f + n.height;\n\n          if (E = Math.min(i, E), b = Math.max(a, b), y = Math.min(f, y), I = Math.max(c, I), !t.virtual) {\n            var h = (i + a) / 2 - n.traceWidth / 2,\n                s = t.hops.map(function (t) {\n              return {\n                start: h,\n                end: h += u[t.traceIndex],\n                traceIndex: t.traceIndex\n              };\n            });\n            x.nodes.push({\n              bounds: new e(i, f, a, c),\n              horizontal: o,\n              hops: t.hops.map(function (t) {\n                return t.origHop;\n              }),\n              traceIndexes: t.hops.map(function (t) {\n                return t.traceIndex;\n              }),\n              traceStops: s\n            });\n          }\n        });\n      }), x.bounds = new e(E, y, b, I), x;\n    }(t, i);\n\n    return r ? {\n      bounds: o(u.bounds),\n      traces: u.traces.map(function (t) {\n        return Object.assign({}, t, {\n          points: t.points.map(function (t) {\n            return [t[1], t[0]];\n          })\n        });\n      }),\n      nodes: u.nodes.map(function (t) {\n        return Object.assign({}, t, {\n          bounds: o(t.bounds)\n        });\n      })\n    } : u;\n  }\n\n  var i = {};\n  return Object.keys(t).forEach(function (n) {\n    r[n] = function (e) {\n      return 0 === arguments.length ? t[n] : (t[n] = e, i[n] = \"function\" == typeof e ? e : function () {\n        return e;\n      }, r);\n    }, r[n](t[n]);\n  }), r;\n}\n\nr.left.get = function () {\n  return this._l;\n}, r.top.get = function () {\n  return this._t;\n}, r.right.get = function () {\n  return this._r;\n}, r.bottom.get = function () {\n  return this._b;\n}, r.x.get = function () {\n  return this.left;\n}, r.y.get = function () {\n  return this.top;\n}, r.cx.get = function () {\n  return (this.left + this.right) / 2;\n}, r.cy.get = function () {\n  return (this.top + this.bottom) / 2;\n}, r.width.get = function () {\n  return this.right - this.left;\n}, r.height.get = function () {\n  return this.bottom - this.top;\n}, e.prototype.expanded = function (t, n, r, o) {\n  return void 0 === n && (n = t), void 0 === r && (r = t), void 0 === o && (o = n), new e(this.left - t, this.top - n, this.right + r, this.bottom + o);\n}, Object.defineProperties(e.prototype, r);\nexport { h as traceCurve, s as nodeGradient, d as genUID, l as tracegraph };","map":{"version":3,"sources":["../src/util.js","../src/rect.js","../src/calc.js","../src/index.js"],"names":["cmp","a","b","sorted","iterable","key","func","x","result","Array","from","i","length","index","value","sort","let","things","cb","tmp","len","permute","slice","orig","j","pick","Rect","constructor","left","top","right","bottom","_l","_r","_t","_b","prototypeAccessors","this","y","cx","cy","width","height","expanded","flippedRect","ref","calcLevel","node","cache","has","get","level","hops","reduce","hop","Math","max","prev","forEach","set","nodeify","_traces","nodes","Map","traces","map","trace","nodeId","virtual","id","Set","next","traceIndexes","newHop","Object","push","add","traceIndex","newHops","uniques","counts","count","maxLevel","levels","rankedNodes","traceRanks","nodeRanks","rank","Infinity","min","rankedHops","hopRanks","crossings","abs","origTraces","options","hopIndex","defined","hopDefined","hopLevel","origHop","virtualize","collectLevels","bestTraceRanks","minCrossings","_","countCrossings","traceCurve","points","x1","y1","dx","smoothness","horizontal","x0","dy","y0","join","nodeGradient","start","traceStops","s","end","stops","offset","gradientUnits","x2","y2","genUID","base","window","location","href","replace","random","document","getElementById","attr","toString","Boolean","levelMargin","traceSmoothness","traceWidths","traceWidth","calc","nodeMetrics","nm","total","nodeSize","maxNodeWidth","sortedTraceWidths","leeway","acc","cur","overlaps","maxOverlaps","hopMetrics","traceOffset","leftHop","lnm","normalLen","sqrt","nudge","levelMetrics","totalHeight","hm","bounds","sections","cut","joinedSections","splice","section","joined","rhm","rnm","rlm","lhm","llm","lm","tracegraph","values","graph","args","verticalGraph","keys","arguments"],"mappings":"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","sourcesContent":["function cmp(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  return a < b ? -1 : 1;\n}\n\nexport function sorted(iterable, key = null) {\n  let func;\n  if (key === null) {\n    func = x => x;\n  } else if (typeof key === \"function\") {\n    func = key;\n  } else {\n    func = x => x[key];\n  }\n\n  const result = Array.from(iterable);\n  for (let i = 0; i < result.length; i++) {\n    result[i] = { index: i, key: func(result[i]), value: result[i] };\n  }\n  // Ensure that sorting is stable by comparing original indexes if the keys are\n  // equal.\n  result.sort((a, b) => cmp(a.key, b.key) || cmp(a.index, b.index));\n  for (let i = 0; i < result.length; i++) {\n    result[i] = result[i].value;\n  }\n  return result;\n}\n\nexport function permutations(things, cb) {\n  const tmp = Array.from(things);\n  const len = tmp.length;\n\n  function permute(i) {\n    if (i === len) {\n      cb(tmp.slice());\n      return;\n    }\n\n    const orig = tmp[i];\n    for (let j = i; j < len; j += 1) {\n      const pick = tmp[j];\n      tmp[j] = orig;\n      tmp[i] = pick;\n      permute(i + 1);\n      tmp[j] = pick;\n    }\n    tmp[i] = orig;\n  }\n  return permute(0);\n}\n","export class Rect {\n  constructor(left, top, right, bottom) {\n    this._l = left;\n    this._r = right;\n    this._t = top;\n    this._b = bottom;\n  }\n  get left() {\n    return this._l;\n  }\n  get top() {\n    return this._t;\n  }\n  get right() {\n    return this._r;\n  }\n  get bottom() {\n    return this._b;\n  }\n  get x() {\n    return this.left;\n  }\n  get y() {\n    return this.top;\n  }\n  get cx() {\n    return (this.left + this.right) / 2;\n  }\n  get cy() {\n    return (this.top + this.bottom) / 2;\n  }\n  get width() {\n    return this.right - this.left;\n  }\n  get height() {\n    return this.bottom - this.top;\n  }\n  expanded(left, top = left, right = left, bottom = top) {\n    return new Rect(\n      this.left - left,\n      this.top - top,\n      this.right + right,\n      this.bottom + bottom\n    );\n  }\n}\n\nexport function flippedRect({ left, top, right, bottom }) {\n  return new Rect(top, left, bottom, right);\n}\n","import { sorted, permutations } from \"./util\";\n\nfunction calcLevel(node, cache) {\n  if (cache.has(node)) {\n    return cache.get(node);\n  }\n  let level = node.hops.reduce((level, hop) => Math.max(level, hop.level), 0);\n  node.prev.forEach(prev => {\n    level = Math.max(calcLevel(prev, cache) + 1, level);\n  });\n  cache.set(node, level);\n  return level;\n}\n\nfunction nodeify(_traces) {\n  // Turn hops into nodes and augment hops with nodes.\n  // Return a new, better trace.\n\n  const nodes = new Map();\n  const traces = _traces.map(trace => {\n    const hops = trace.hops.map(hop => {\n      const nodeId = `${hop.virtual ? \"virtual\" : \"real\"}-${hop.nodeId}`;\n      const node = nodes.get(nodeId) || {\n        id: nodeId,\n        virtual: hop.virtual,\n        hops: [],\n        level: 0,\n        prev: new Set(),\n        next: new Set(),\n        traceIndexes: new Set()\n      };\n      nodes.set(nodeId, node);\n\n      const newHop = {\n        ...hop,\n        nodeId,\n        node\n      };\n      node.hops.push(newHop);\n      node.traceIndexes.add(newHop.traceIndex);\n      return newHop;\n    });\n    return {\n      ...trace,\n      hops\n    };\n  });\n\n  traces.forEach(trace => {\n    const hops = sorted(trace.hops, \"level\");\n    for (let i = 1; i < hops.length; i++) {\n      const left = hops[i - 1];\n      const right = hops[i];\n      if (right.level === left.level + 1) {\n        right.node.prev.add(left.node);\n        left.node.next.add(right.node);\n      }\n    }\n  });\n\n  const cache = new Map();\n  nodes.forEach(node => {\n    node.level = calcLevel(node, cache);\n    node.hops.forEach(hop => (hop.level = node.level));\n  });\n  return traces;\n}\n\nfunction virtualize(traces) {\n  return traces.map(trace => {\n    const newHops = [];\n\n    const hops = sorted(trace.hops, \"level\");\n    hops.forEach((hop, index) => {\n      if (index > 0) {\n        const prev = hops[index - 1];\n        for (let i = prev.level + 1; i < hop.level; i++) {\n          newHops.push({\n            ...prev,\n            level: i,\n            virtual: true,\n            nodeId: `${i}-${prev.nodeId}`\n          });\n        }\n      }\n      newHops.push({\n        ...hop,\n        nodeId: `${hop.level}-${hop.nodeId}`\n      });\n    });\n    return {\n      ...trace,\n      hops: newHops\n    };\n  });\n}\n\nfunction uniques(hops) {\n  // Create multiple hops if one trace contains the same grouping key several times\n\n  const counts = new Map();\n  return sorted(hops, \"level\").map(hop => {\n    const nodeId = hop.nodeId;\n    const count = counts.get(nodeId) || 0;\n    counts.set(nodeId, count + 1);\n    return {\n      ...hop,\n      nodeId: `${count}-${nodeId}`\n    };\n  });\n}\n\nfunction collectLevels(traces) {\n  let maxLevel = 0;\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      maxLevel = Math.max(maxLevel, hop.level);\n    });\n  });\n\n  const levels = new Array(maxLevel + 1);\n  for (let i = 0; i < levels.length; i++) {\n    levels[i] = new Set();\n  }\n  traces.forEach(trace => {\n    trace.hops.forEach(hop => {\n      levels[hop.level].add(hop.node);\n    });\n  });\n\n  return levels.map(nodes => {\n    return Array.from(nodes);\n  });\n}\n\nfunction rankedNodes(nodes, traceRanks) {\n  const nodeRanks = new Map();\n  nodes.forEach(node => {\n    let rank = Infinity;\n    node.traceIndexes.forEach(traceIndex => {\n      rank = Math.min(rank, traceRanks[traceIndex]);\n    });\n    nodeRanks.set(node, rank);\n  });\n  return sorted(nodes, node => nodeRanks.get(node));\n}\n\nfunction rankedHops(hops, traceRanks) {\n  return sorted(hops, hop => traceRanks[hop.traceIndex]);\n}\n\nfunction countCrossings(traces, levels, traceRanks) {\n  const hopRanks = new Map();\n  levels.forEach(nodes => {\n    let rank = 0;\n    rankedNodes(nodes, traceRanks).forEach(node => {\n      rankedHops(node.hops, traceRanks).forEach(hop => {\n        hopRanks.set(hop, rank);\n        rank += 1;\n      });\n    });\n  });\n\n  let crossings = 0;\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 0; i < hops.length - 1; i++) {\n      crossings += Math.abs(hopRanks.get(hops[i]) - hopRanks.get(hops[i + 1]));\n    }\n  });\n\n  return crossings;\n}\n\nexport default function(origTraces, options) {\n  const enrichedTraces = origTraces.map((trace, traceIndex) => {\n    const hops = trace.hops.map((hop, hopIndex) => ({\n      traceIndex,\n      hopIndex,\n      nodeId: options.nodeId(hop, hopIndex, trace, traceIndex, origTraces),\n      node: null,\n      defined: options.hopDefined(hop, hopIndex, trace, traceIndex, origTraces),\n      level: options.hopLevel(hop, hopIndex, trace, traceIndex, origTraces),\n      virtual: false,\n      origHop: hop\n    }));\n    return {\n      hops: uniques(hops)\n    };\n  });\n  const traces = nodeify(virtualize(nodeify(enrichedTraces))).map(trace => ({\n    ...trace,\n    hops: sorted(trace.hops, \"level\")\n  }));\n  const levels = collectLevels(traces);\n\n  let bestTraceRanks = [];\n  let minCrossings = Infinity;\n  permutations(traces.map((_, index) => index), traceRanks => {\n    const crossings = countCrossings(traces, levels, traceRanks);\n    if (crossings < minCrossings) {\n      minCrossings = crossings;\n      bestTraceRanks = traceRanks;\n    }\n  });\n\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      node.hops = rankedHops(node.hops, bestTraceRanks);\n    });\n  });\n\n  return {\n    traces,\n    levels: levels.map(nodes => rankedNodes(nodes, bestTraceRanks))\n  };\n}\n","import { sorted } from \"./util\";\nimport { Rect, flippedRect } from \"./rect\";\nimport calc from \"./calc\";\n\nexport function traceCurve() {\n  return function({ points, horizontal, smoothness }) {\n    return points\n      .map(([x1, y1], index) => {\n        if (index === 0) {\n          return `M ${x1} ${y1}`;\n        }\n        const [x0, y0] = points[index - 1];\n        const dx = smoothness * (horizontal ? x1 - x0 : 0);\n        const dy = smoothness * (horizontal ? 0 : y1 - y0);\n        return `C ${x0 + dx} ${y0 + dy},  ${x1 - dx} ${y1 - dy}, ${x1} ${y1}`;\n      })\n      .join(\" \");\n  };\n}\n\nexport function nodeGradient(node) {\n  const { horizontal, traceStops } = node;\n\n  const start = Math.min(...traceStops.map(s => s.start));\n  const end = Math.max(...traceStops.map(s => s.end));\n\n  const stops = [];\n  traceStops.forEach(s => {\n    stops.push(\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.start - start) / (end - start)\n      },\n      {\n        traceIndex: s.traceIndex,\n        offset: (s.end - start) / (end - start)\n      }\n    );\n  });\n\n  return {\n    gradientUnits: \"userSpaceOnUse\",\n    x1: horizontal ? 0 : start,\n    y1: horizontal ? start : 0,\n    x2: horizontal ? 0 : end,\n    y2: horizontal ? end : 0,\n    stops: sorted(stops, \"offset\")\n  };\n}\n\nexport function genUID() {\n  const base = window.location.href.replace(/#.*/, \"\");\n\n  for (;;) {\n    const id = `uid-${Math.random()}`;\n    if (!document.getElementById(id)) {\n      const attr = `url(${base}#${id})`;\n      return {\n        id,\n        toString() {\n          return attr;\n        }\n      };\n    }\n  }\n}\n\nfunction verticalGraph(origTraces, options) {\n  const horizontal = Boolean(options.horizontal());\n  const levelMargin = options.levelMargin();\n  const traceSmoothness = options.traceSmoothness();\n  const traceWidths = origTraces.map((trace, index) => {\n    return options.traceWidth(trace, index, origTraces);\n  });\n\n  const { traces, levels } = calc(origTraces, options);\n\n  const nodeMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        traceWidth: node.hops.reduce(\n          (total, hop) => total + traceWidths[hop.traceIndex],\n          0\n        )\n      };\n      if (!node.virtual) {\n        const [width, height] = options.nodeSize({\n          hops: node.hops.map(hop => hop.origHop),\n          horizontal: Boolean(horizontal)\n        });\n        nm.width = width;\n        nm.height = height;\n      }\n      nm.width = Math.max(nm.width, nm.traceWidth);\n      nodeMetrics.set(node, nm);\n    });\n  });\n\n  let maxNodeWidth = 0;\n  nodeMetrics.forEach(nm => {\n    maxNodeWidth = Math.max(nm.width, maxNodeWidth);\n  });\n  const sortedTraceWidths = sorted(traceWidths);\n  levels.forEach(nodes => {\n    let width = maxNodeWidth;\n    if (nodes.length >= 2) {\n      const leeway = sortedTraceWidths\n        .slice(nodes.length - 1)\n        .reduce((acc, cur) => acc + cur, 0);\n      width = (maxNodeWidth + leeway) / 2;\n    }\n    nodes.forEach((node, index) => {\n      nodeMetrics.get(node).x += (index - (nodes.length - 1) / 2) * width;\n    });\n\n    let overlaps = 0;\n    let maxOverlaps = 0;\n    nodes.forEach(node => {\n      if (node.virtual) {\n        overlaps = 0;\n      } else {\n        overlaps += 1;\n        maxOverlaps = Math.max(overlaps, maxOverlaps);\n      }\n    });\n    nodes.forEach((node, index) => {\n      let y = 0;\n      if (maxOverlaps >= 2 && index % 2 === 0) {\n        const left = index === 0 ? 0 : nodeMetrics.get(nodes[index - 1]).height;\n        const right =\n          index === nodes.length - 1\n            ? 0\n            : nodeMetrics.get(nodes[index + 1]).height;\n        y += Math.max(left, right);\n      }\n      nodeMetrics.get(node).y = y;\n    });\n  });\n\n  const hopMetrics = new Map();\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n\n      let traceOffset = 0;\n      node.hops.forEach(hop => {\n        const traceWidth = traceWidths[hop.traceIndex];\n        hopMetrics.set(hop, {\n          traceWidth,\n          traceOffset,\n          x: nm.x + traceOffset + traceWidth / 2 - nm.traceWidth / 2,\n          top: 0,\n          bottom: 0\n        });\n        traceOffset += traceWidth;\n      });\n    });\n  });\n\n  traces.forEach(trace => {\n    const hops = trace.hops;\n    for (let i = 1; i < hops.length; i++) {\n      const leftHop = hops[i - 1];\n      const left = hopMetrics.get(leftHop);\n      const right = hopMetrics.get(hops[i]);\n      const lnm = nodeMetrics.get(leftHop.node);\n\n      const dy = (3 / 2) * (1 - traceSmoothness) * (2 * levelMargin);\n      const dx = (3 / 2) * (right.x - left.x);\n      const normalLen = Math.sqrt(dx * dx + dy * dy);\n\n      let nudge = 0;\n      if (normalLen > 0) {\n        // Correction\n        const xfix = 1 - dy / normalLen;\n        const slope = dx !== 0 ? dy / dx : 0;\n        const offset = dx / normalLen - slope * xfix;\n\n        if (dx > 0) {\n          nudge =\n            (lnm.traceWidth - left.traceOffset - left.traceWidth) * offset;\n        } else {\n          nudge = -left.traceOffset * offset;\n        }\n      }\n      left.bottom = nudge;\n      right.top = nudge;\n    }\n  });\n\n  const levelMetrics = new Map();\n  let totalHeight = 0;\n  levels.forEach((nodes, level) => {\n    let top = 0;\n    nodes.forEach(node => {\n      node.hops.forEach(hop => {\n        const hm = hopMetrics.get(hop);\n        top = Math.max(hm.top, top);\n      });\n    });\n\n    let height = 0;\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      height = Math.max(height, nm.height + nm.y);\n    });\n\n    levelMetrics.set(level, {\n      top,\n      height,\n      y: totalHeight\n    });\n    totalHeight += height + top + 2 * levelMargin;\n  });\n\n  const result = {\n    nodes: [],\n    traces: [],\n    bounds: null\n  };\n\n  traces.forEach((trace, traceIndex) => {\n    const sections = [];\n\n    const hops = trace.hops;\n    hops.forEach((hop, index) => {\n      if (hop.virtual) {\n        return;\n      }\n\n      let cut = index - 1;\n      while (cut >= 0 && hops[cut].virtual) {\n        cut--;\n      }\n      if (cut >= 0) {\n        sections.push({\n          hops: hops.slice(cut, index + 1),\n          defined: hops[cut].defined && hop.defined\n        });\n      }\n    });\n\n    const joinedSections = sections.splice(0, 1);\n    sections.forEach(section => {\n      const joined = joinedSections[joinedSections.length - 1];\n      if (Boolean(section.defined) === Boolean(joined.defined)) {\n        joined.hops.push(...section.hops.slice(1));\n      } else {\n        joinedSections.push(section);\n      }\n    });\n\n    const pointSections = joinedSections.map(({ hops, defined }) => {\n      const points = [];\n      hops.forEach((right, index) => {\n        const rhm = hopMetrics.get(right);\n        const rnm = nodeMetrics.get(right.node);\n        const rlm = levelMetrics.get(right.level);\n        if (index === 0) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n          return;\n        }\n\n        const lhm = hopMetrics.get(hops[index - 1]);\n        const llm = levelMetrics.get(hops[index - 1].level);\n        const y = llm.y + llm.top + llm.height + lhm.bottom;\n        points.push([lhm.x, y]);\n        points.push([rhm.x, y + 2 * levelMargin]);\n\n        if (index === hops.length - 1) {\n          points.push([rhm.x, rlm.y + rlm.top + rnm.y + rnm.height / 2]);\n        }\n      });\n      return { points, defined };\n    });\n\n    pointSections.forEach(section => {\n      result.traces.push({\n        index: traceIndex,\n        width: traceWidths[traceIndex],\n        hops: trace.hops.map(hop => hop.origHop),\n        defined: section.defined,\n        points: section.points,\n        smoothness: traceSmoothness,\n        horizontal: horizontal\n      });\n    });\n  });\n\n  let left = levels.length === 0 ? 0 : Infinity;\n  let right = levels.length === 0 ? 0 : -Infinity;\n  let top = levels.length === 0 ? 0 : Infinity;\n  let bottom = levels.length === 0 ? 0 : -Infinity;\n  levels.forEach(nodes => {\n    nodes.forEach(node => {\n      const nm = nodeMetrics.get(node);\n      const lm = levelMetrics.get(node.level);\n      const x0 = nm.x - nm.width / 2;\n      const x1 = nm.x + nm.width / 2;\n      const y0 = lm.y + lm.top + nm.y;\n      const y1 = y0 + nm.height;\n\n      left = Math.min(x0, left);\n      right = Math.max(x1, right);\n      top = Math.min(y0, top);\n      bottom = Math.max(y1, bottom);\n      if (node.virtual) {\n        return;\n      }\n\n      let offset = (x0 + x1) / 2 - nm.traceWidth / 2;\n      const traceStops = node.hops.map(hop => {\n        const start = offset;\n        offset += traceWidths[hop.traceIndex];\n        return {\n          start,\n          end: offset,\n          traceIndex: hop.traceIndex\n        };\n      });\n      result.nodes.push({\n        bounds: new Rect(x0, y0, x1, y1),\n        horizontal,\n        hops: node.hops.map(hop => hop.origHop),\n        traceIndexes: node.hops.map(hop => hop.traceIndex),\n        traceStops\n      });\n    });\n  });\n\n  result.bounds = new Rect(left, top, right, bottom);\n  return result;\n}\n\nexport function tracegraph() {\n  const values = {\n    horizontal: false,\n    traceWidth: () => 1,\n    traceSmoothness: 0.5,\n    levelMargin: 10,\n    hopLevel: (hop, index) => index,\n    hopDefined: () => true,\n    nodeSize: () => [10, 10],\n    nodeId: (hop, hopIndex, trace, traceIndex) => `${traceIndex}-${hopIndex}`\n  };\n\n  function graph(traces) {\n    const horizontal = options.horizontal();\n    if (horizontal) {\n      const nodeSize = options.nodeSize;\n      options.nodeSize = (...args) => {\n        const [w, h] = nodeSize(...args);\n        return [h, w];\n      };\n    }\n\n    const result = verticalGraph(traces, options);\n    if (!horizontal) {\n      return result;\n    }\n    return {\n      bounds: flippedRect(result.bounds),\n      traces: result.traces.map(trace => ({\n        ...trace,\n        points: trace.points.map(([x, y]) => [y, x])\n      })),\n      nodes: result.nodes.map(node => ({\n        ...node,\n        bounds: flippedRect(node.bounds)\n      }))\n    };\n  }\n\n  const options = {};\n  Object.keys(values).forEach(key => {\n    graph[key] = function(value) {\n      if (arguments.length === 0) {\n        return values[key];\n      }\n      values[key] = value;\n      options[key] = typeof value === \"function\" ? value : () => value;\n      return graph;\n    };\n    graph[key](values[key]);\n  });\n  return graph;\n}\n"]},"metadata":{},"sourceType":"module"}